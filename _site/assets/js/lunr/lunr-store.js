var store = [{
        "title": "Markdown's Usage",
        "excerpt":"  Markdown is a text-to-HTML conversion tool for web writers. Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML).I have known Markdown for a year. First use the Marxico as a supplement of evernote. But today I want to find a freedom way to write technical articles. Because the jekyll’s default markdown is Kramdown, and I research all the markdown syntaxs and find Kramdown is the most active and functional. So I just learn and review the basic syntaxs with the experience using Marxico.I use the Kramdown Quick Reference as the learning material.Block-level ElementsParagraphsYou have to add a blank line toseparate different block level elements.Explicit line breaks in a paragraph can bemade by using two spaces at the end of a line.HeadersI prefer the “#” style headers.Different numbers of “#” show the different level of headers just like this article.A header must be preceded by a blank line.Blockquotes  A blockquote is started using the “&gt;” marker  Other block-level elements can be used in a blockquote      Use the Nested blockquotes    if there is no blank lineeven no “&gt;” is OK.After a blank line it’s a separate paragraph.Code BlocksLines indented with one tab is the code block.use tilde characters to    specify a code block with a language.Horizontal RulesUse three or more asterisks to insert a horizontal rule.Lists  Start with a number, a period, a space and the content.            have a blockquote here        a paragraphhere  Nested list          hello      hey      hi        several elementsWhy not  Look so ugly* no number* equal treatmentTables            Name      Address      Tel                  mike      Xi’an      110              Alice      Shanghai      120              John      Beijing      119      Span-Level ElementsEmphasisUse asterisks to emphasized words.Use double asterisks to strong emphasized words.Links and ImagesHere is my homepageHere is a picture:Inline CodeUse backticks to surrouding the inline codeUse `two backticks to express literal backticks in the code`FootnotesSet a footnote marker1.Need a better one2?            Consists of square brackets with a caret and the footnote name.&nbsp;&#8617;                      Surprise!            &#8617;      ","categories": ["笔记"],
        "tags": ["工具","markdown","语法"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/markdown-usage/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Use Shadowsocks to over the GFW",
        "excerpt":"Live in China, learn how to over the GFW is the nesessary skill to google. As VPNs are expensive and risky to be blocked, and goagent is slow and not stable, shadowsocks is a great choice for explorers.What is shadowsocksShadowsocks is a secure sock5 proxy that provides an encrypted tunnel to bypass the firewalls.How to set upIf you want to use shadowsocks, you need to have a VPS as your shadowsocks server. Here I use the DigitalOcean 512M/20G droplet. It has a moderate price and a good speed, which cost $5 per month and has 1000G Transfer.(If you are a student, github has a student package including $100 for DigitalOcean).Remember choose a good datacenter region. Most people recommend San Francisco for it’s in the America West.I select Ubuntu 14.04 as my server os. How to install just refer DigitalOcean’s help.Set up the serverIn the Ubuntu os, install server is easy:apt-get install python-pippip install shadowsocksAlthough it can be configurated by the command line, I prefer by the config file.Create a config file /etc/shadowsocks.json like the following:{    \"server\": \"192.241.219.20\",    \"server_port\": 8388,    \"local_address\": \"127.0.0.1\",    \"local_port\": 1080,    \"password\": \"overthegfw\"    \"timeout\": 300,    \"method\": \"aes-256-cfb\"}Then you can run the server in the backgroud:ssserver -c /etc/shadowsocks.json -d startIf you want to stop it:ssserver -c /etc/shadowsocks.json -d stopif you want to check the log:less /var/log/shadowsocks.logSet up the clientOSXPersonally I use a MBP, and Shadowsocks for OSX as the client.In fact, Shadowsocks for OSX has a auto proxy mode with a GFWList PAC, in the most time you just open the auto proxy mode and surf the Internet without blocks. However, there are some websites are blocked and haven’t been updated in the GFWList. In such situation, we need the Chrome and its add-on SwitchyOmega. The project has a detailed introduction and installation and configuration.IOSI have some good news. Shadowsocks for IOS can’t apply to IOS 9. But some alternative apps have shown up. I choose the cheapest one: shadowrocket. It just work like a VPN. For me, that’s enough.OK, let’s enjoy the Internet rather than the Chinese Intranet!","categories": ["工具"],
        "tags": ["翻墙","shadowsocks"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/shadowsocks/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Data Mining Introduction",
        "excerpt":"Why Date Mining?  Moving toward to Information Age  Date Mining as the Evolution of Information Technology          Date Collection and Database Creation      Database Management Systems      Advanced Database Systems &amp; Advanced Data Analysis      Future Generation of Information Systems      What is Data Mining?  Data cleaning  Data integration  Data selection  Data transformation  Data mining  Pattern evaluation  Knowledge presentationWhat Kinds of Data Can Be Mined?  Database Data  Data Warehouses  Transactional Data  Other Kinds of DataWhat kinds of Patterns Can Be Mined?  Class/Concept Description: Characterization and Discrimination  Mining Frequent Patterns, Associations, and Correlations  Classification and Regression for Predictive Analysis  Cluster Analysis  Outlier Analysis  An interesting pattern represents knowledge.Which Technologies Are Used?  Statics  Machine Learning          Supervised learing      Unsupervised learning      Semi-supervised learning      Active learning        Database Systems and Data Warehouses  Information Retrieval  Others          Pattern recognition      Visualization      Algorithms      High-performance computing      Which Kinds of Applications Are Targeted?  Business Intelligence  Web Search EnginesMajor Issues in Data Mining  Mining Methodology  User Interaction  Efficiency ans Scalability  Diversity of Dababase Types  Data Mining and Society","categories": ["机器学习"],
        "tags": ["机器学习","数据挖掘"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/data-mining-introduction/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Getting to Know Your Data",
        "excerpt":"Data Objects and Attribute Types  Nominal Attributes  Binary Attributes  Ordinal Attributes  Numeric Attributes          Interval-Scaled Attributes      Ratio-Scaled Attributes      Basic Statistical Descriptions of DataMeasuring the Central TendencyMeanMedian is the lower boundary of the median interval. is the number of values in the entire data set. is the sum of the frequencies of all of the intervals that lower than the median interval. is the frequency of the median interval. is the width of the median interval.ModeApplied to unimodal numeric data that are moderately skewed (asymmetrical).MidrangeMeasuring the Dispersion of DataRange, Quartiles, and Interquartile RangeRangeThe difference between the largest and smallest values.QuantilesThe points taken at regular intervals of a data distribution.quartilesThe 4-quantilesInterquartile rangeThe distance between the first and third quartiles.Five-Number Summary, Boxplots, and OutliersFive-Number SummaryBoxplotsA way of visulizing a distribution using Five-Number Summary.OutliersThe whiskers are extended to  of the quartiles. Others are Outliers and plotted individually.Variance and Standard Deviation   meassures spread about the mean and should be considered onlu when the mean is chosen as the measure of center.  Using Chebyshev’s inequality show that at least  of the obesrvations are no more than k standard deviations from the mean.Graphic Display of Basic Statistical Description of Data  Quantile plot  Quantile-Quantile plot  Histograms  Scatter plotData Visualization  Pixel-Oriented Visualization Techniques  Geometric Projection Visualization Techniques  Icon-Based Visualization Techniques  Hierarchical Visualization Techniques  Tag cloud and tree-mapMeasuring Data Similarity and DissimilarityData Matrix versus Dissimilarity MatrixData MatrixDissimilarity MatrixProximity Measures for Nominal Attributesm is the number of matchesp is the total number of attributesProximity Measures for Binary Attributes  q: (i,j) = (1,1)  r: (i,j) = (1,0)  s: (i,j) = (0,1)  t: (i,j) = (0,0)Symmetric Binary DissimilarityAsymmetric Binary DissimilarityDissimilarity of Numeric DataEuclidean distanceWeighted Euclidean distanceManhattan distance  Non-negativity:   Identity of indiscernibles:   Symmetry: d(i,j) = d(j,i)  Triangle inequality: Minkowski distanceSupremum distance(,  norm, Chebyshev distance)Proximity Measures for Ordinal AttributesDissimilarity for Attributes of Mixed Types  f is numeric:  f is nominal or binary:  if ; otherwise,   f is ordinal: Cosine SimilarityA simple variation frequently used in information retrieval and biology taxnomy.","categories": ["机器学习"],
        "tags": ["机器学习","数据挖掘"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/get-to-know-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 00 - Introduction",
        "excerpt":"Why Use The Command Line?Graphical users interfaces make easy tasks easy, while command line interfaces make difficult tasks possible.What This Book Is About  The book is a broad overview of “living” on the Linux command line.  The book is not about Linux system administration  The book is very Linux-centricWho Should Read This Book  Who migrate from other platforms  Learn the Linux command line is not easy but rewardingWhat’s In This Book  Part 1 - Learning The Shell  Part 2 - Configuration And The Environment  Part 3 - Common Tasks And Essential Tools  Part 4 - Writing Shell Scripts","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter00-Introduction/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 01 - What Is The Shell?",
        "excerpt":"  date - Display the current time and date  cal - Display a calendar of the current month  df - Display the free space of disk drives  free - Display the free memory  exit - Ending a terminalShell is a program that takes keyboard commands and passes them to the operating system to carry out.  bash: Bourne Again Shell, an replacement of shTerminal EmulatorsGive us access to the shellYour First KeystrokesShell prompt: [me@linuxbox ~]$if the last character is #, show it has superuser privilegesCommand Historyup-arrow, down-arrowCursor MovementLeft-arrow, Right-arrow      Highlight text by holding down the left mouse button and dragging down the mouse or double clicking on a word, it is copied into a buffer, pressing the middle mouse button to paste it.        “Click to focus” and “focus follows mouse”  Try Some Simple CommandsDisplay the current time and date\tdateDisplay a calendar of the current month\tcalDisplay the free space of disk drives\tdfDisplay the free memory\tfreeEnding A Terminal Session\texitThe Console Behind The Curtain      Virtual terminals Ctrl-Alt-F1 ~ Ctrl-Alt-F6        Return graphical desktop Alt-F7  ","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter01-What-Is-The-Shell/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 02 - Navigation",
        "excerpt":"  pwd - Display the current working directory  ls - List the files and directories in the current working directory  cd - Change the current working directoryUnderstanding The File System Tree  Hierarchical directory structure  Linux always have a single file system treeThe Current Working DirectoryDisplay the current working directorypwdHome directory: the only place a regular user is allowed to write filesListing The Contents Of A DirectoryList the files and directories in the current working directorylsChanging The Current Working DirectoryAbsolute Pathnamescd /usr/binRelative Pathnames.. refers to the parent directorycd ... refers to the current directory and always can be omitcd ./bin or cd binSome Helpful ShortcutsChanges to home directorycdChanges to previous directorycd -Changes to home directory of user_namecd ~user_nameImportant Facts About Filenames  Filenames that begin with a period character are hidden. Display them by ls -a  Filenames and commands in Linux are case sensitive  Linux has no concept of file extension  Limit the punctuation characters in the names of files you create to . period, - dash and _ underscore.","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter02-Navigation/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 03 - Explore the System",
        "excerpt":"  ls - List the files and directories in current working directory  file - Determine a file’s type with file  less - View file contentsMore Fun With lsspecify multiple directoriesls ~ /usrOptions And Argumentscommand -options argumentsshort options and long optionsls -lt --reverseCommon ls Options            Option      Long Option      Description                  -a      –all      List all files              -A      –almost-all      Like -a except not list . and ..              -d      –directory      Use with -l to see detail about the directory              -F      –classify      Append an indicator character to the end of each listed name              -h      –human-readable      Display file sizes in human readable format rather than in bytes              -i      –inode      Reveal the inode information              -l             Display results in long format              -r      –reverse      Display results in reverse order              -s             Sort results by file size              -t             Sort by modification time      A Longer Look At Long Format-rw-r--r-- 1 root root 32059 2007-04-03 11:05 oo-cd-cover.odfIs Long Listing Fields            Field      Meaning                  -rw-r--r--      Access rights to the file              1      File’s number of hard links              root      The username of the file’s owner              root      The name of the group which owns the file              32059      Size of the file in bytes              2007-04-03 11:05      Date and time of the file’s last modification              oo-cd-cover.odf      Name of the file      Determining A File’s Type With filefile filenamefile picture.jpgViewing File Contents With lessless filenameless /etc/passwdless Commands            Command      Action                  Page Up or b      Scroll back one page              Page Down or space      Scroll forward one page              Up Arrow      Scroll up one line              Down Arrow      Scroll down one line              G      Move to the end of the text file              1G or g      Move to the beginning of the text file              /characters      Search forward to the next occurrence of characters              n      Search for the next occurrence of the previous search              h      Display help screen              q      Quit less        Less Is MoreA Guided TourDirectories Found On Linux Systems            Directory      Comments                  /      The root directory              /bin      Contains binaries that must be present to boot and run              /boot      Contains the Linux kernel, initial RAM and the boot loader              /dev      Contains device nodes              /etc      Contains all the system-wide configuration files              /home      Contains users’ Directory              /lib      Contains shared library files used by the core system programs              /lost+found      Used in the case of a partial recovery from a file system corruption event              /media      Contain the mount points for removable media such as USB              /mnt      Contains mount points for removable devices mounted manuallly              /opt      used to install “optional” software mainly for commercial software              /proc      A virtual file system, Contains feepholes into the kernel              /root      The home directory for the root account              /sbin      Contains “system”binaries, perform vital system tasks              /tmp      Contains temporary files created by various programs              /usr      Contains all the programs and support files used by regular users              /usr/bin      Contains the executable programs installed by Linux distribution              /usr/lib      The shared libraries for the programs in /usr/bin              /usr/local      Contain programs complied from source code              /usr/sbin      Contains more system administration programs              /usr/share      Contains all the shared data used by programs in /usr/bin              /usr/share/doc      Contains package documentations              /var      Where data that is likely to change is stored              /var/log      contains log files records of various system activity      Symbolic Linkslrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc. so. 6 -&gt; libc-2.6.soHard LinksA second type of link","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter03-Exploring-The-System/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 04 - Manipulating Files and Directories",
        "excerpt":"  mkdir - Create directories  cp - Copy files and directories  mv - Move and rename files  rm - Remove files and directories  ln - Create linksWildcardsWildcard            Wildcard      Meaning                  *      Matches any characters              ?      Matches any single character              [characters]      Matches any character that is a member of the set characters              !characters      Matches any character that is not a member of the set characters              [[:class:]]      Matches any character that is a member of the specified class      Commonly Used Character Classes            Character Class      Meaning                  [:alnum:]      Matches any alphanumeric character              [:alpha:]      Matches any alphabetic character              [:digit:]      Matches any numeral              [:lower:]      Matches any lowercase letter              [:upper:]      Matches any uppercase letter      Wildcard Examples            Pattern      Matches                  *      All files              g*      Any file beginning with “g”              b*.txt      Any file beginning with “b” followed by any characters and ending with “.txt”              Data???      Any file beginning with “Data” followed by exactly three characters              [abc]*      Any file beginning with either an “a”, a “b”, or a “c”              BACKUP.[0-9][0-9][0-9]      Any file beginning with “BACKUP.” followed by exactly three numerals              [[:upper:]]*      Any file beginning with an uppercase letter              [![:digit:]]*      Any file not beginning with a numeral              *[[:lower:]123]      Any file ending with a lowercase letter or the numerals “1”, “2”, “3”      mkdir - Create Directoriesmkdir directory ...      When three periods follow an argument, it means the argument can be repeated    mkdir dir1    mkdir dir1 dir2 dir3  cp - Copy Files And Directoriescopy the single file or directory to file or directorycp item1 item2copy multiple items(either files or directories) into a directoryUseful Options And Examplescp Options            Option      Meaning                  -a, –archive      Copy the files and directories and all of their attributes              -i, –interactive      Before overwriting an existing file, prompt the user for confirmation              -r, –recursive      Recursively copy directories and their contents              -u, –update      Only copy files that either don’t exist, or are newer              -v, –verbose      Display informative messages as the copy is performed      cp Examples            Command      Results                  cp file1 file2      If file2 exists, overwrite. Not exist, create              cp -i file1 file2      Same as above, except prompt before overwrite              cp file1 file2 dir1      Copy file1 and file2 into dir1              cp dir1/* dir2      Copy all the files in dir1 into dir2              cp -r dir1 dir2      If dir2 exist, Copy dir1(and its contents)into dir2. If not, create a dir2 contain same contents as dir1      mv - Move And Rename Filesmove or rename file or directory “item1” to “item2”mv item1 item2 move one or more items from one directory to anothermv item... directoryUseful Options And Examplesmc Options            Option      Meaning                  -i, –interactive      Before overwriting an existing file, prompt the user for confirmation              -u, –update      Only move files that either don’t exist, or are newer              -v, –verbose      Display informative messages as the move is performed      mv Examples            Command      Results                  mv file1 file2      If file2 exists, overwrite. Not exist, create              mv -i file1 file2      Same as above, except prompt before overwrite              mv file1 file2 dir1      Move file1 and file2 into dir1              mv -r dir1 dir2      If dir2 exist, Move dir1(and its contents)into dir2. If not, create a dir2 contain same contents as dir1      rm - Remove Files And Directoriesromove files and directoriesrm item...Useful Options And Examplesrm Options            Option      Meaning                  -i, –interactive      Before deleting an existing file, prompt the user for confirmation              -r, –recursive      Recursively delete directories              -f, –force      Ignore nonexisten files and do not prompt, overrides the -i option              -v, –verbose      Display informative messages as the deletion is performed      rm Examples            Command      Results                  rm file1      Delete file1 silently              rm -i file1      Same as above, except prompt before overwrite              rm -r file1 dir1      Delete file1 and dir1 and its contents              rm -rf file1 dir1      Same as above, except if either file1 or dir1 not exist, continue silently        Be Careful With rm!  A useful tip: use ls before rmIn - Create LinksCreate a hard linkln file linkCreate a symbolic linkln -s item linkHard LinksTwo limitations:  Cannot reference a file outside its own file system  Cannot reference a directoryHard Link file has the same inode as the file, -ioption can reveal inode informationls -liSymbolic LinksBroken link: The file is deleted before the symbolic linkLet’s Build A PlaygroundSee the « The Linux Command Line »  Creating Symlinks With The GUI:Hold Ctrl+Shift when drag the file","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter04-Manipulating-Files-And-Directories/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 05 - Working with Commands",
        "excerpt":"  type - Display a command’s type  which - Display an executable’s location  help - Get help for shell builtins  –help - Display usage information for an executable  man - Display a program’s manual page  apropos - Display appropriate commands  whatis - Display a brief description of a command  info - Display a CNU program’s info entry  alias - Create a alias for commandsWhat Exactly Are Commands?  An executable program  A command built into the shell itself  A shell function  An aliasIdentifying Commandstype - Display A Command’s Typetype commandwhich - Display An Executable’s Locationwhich lsGetting A Command’s Documentationhelp - Get Help For Shell Builtinshelp cd–help - Display Usage Informationmkdir --helpman - Display A Program’s Manual Pageman lsMan Page Organization            Section      Contents                  1      User commands              2      Programming interfaces kernel system calls              3      Programming interfaces to the C library              4      Special files such as device nodes and drivers              5      File formats              6      Games and amusements such as screen savers              7      Miscellaneous              8      System administration commands      man section search_termman 5 passwdapropos - Display Appropriate Commandsapropos floppywhatis - Display A Very Brief Description Of A Commandwhatis lsinfo - Display A GNU Program’s Info Entryinfo coreutilsinfo Commands            Command      Action                  ?      Display command help              PgUp or Backspace      Display previous page              PgDn or Space      Display next page              n      Next - Display the next node              p      Previous - Display the previous node              u      Up - Display the parent node of the currently displayed node, usually a menu              Enter      Follow the hyperlink at the cursor lacation              q      Quit      README And Other Program Documentation FilesFiles end with “.gz” can be opened by zless.Creating Your Own Commands With aliasput more than one command on a line by ;command1; command2; command3...cd /usr; ls; cd -Create an aliasalias name='string'alias foo='cd /usr; ls; cd -'Remove an aliasunalias fooSee all the aliases defined in the environmentalias","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter05-Working-With-Commands/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "IPython Tutorial",
        "excerpt":"IPython Basiclaunch IPythonipythonbasic usagea = 1afrom numpy.random import randndata = {i:randn() for i in range(7)}dataTab Completionan_apple = 27an_example = 42an&lt;Tab&gt;b = [1, 2, 3]b.&lt;Tab&gt;import datatimedatatime.&lt;Tab&gt;book_scripts/&lt;Tab&gt;path = 'book_scripts/&lt;Tab&gt;'Introspectionb?def add_numbers(a,b):    \"\"\"    Add two numbers together    Returns    --------    the sum : type of arguments    \"\"\"    return a + badd_numbers?add_numbers?? # show the function's source code if possiblenp.*load*? # search the IPython namespaceThe %run Command%run ipython_script_test.py%run -i ipython_script_test.py # give the script access to variables defined in the IPython namespace.Ctrl+C to interrupting running codeExecuting Code from the Clipboard%paste%cpaste # enter '--' alone on the line to stop or use `Ctrl+D`IPython interaction with editors and IDEs  vim  Emacs  PyDev for Eclipse  Python Tools for VSKeyboard Shortcuts            Command      Description                  Ctrl+P or uparrow      Search backward in command history for commands starting with currently-entered text              Ctrl+N or down-arrow      Search forward in command history for commands starting with currently-entered text              Ctrl+R      Readline-style reverse history search (partial matching)              Ctrl+Shift-V      Paste text from Clipboard              Ctrl+C      Interrupt currently-executing code              Ctrl+A      Move cursor to beginning of line              Ctrl+E      Move cursor to end of line              Ctrl+K      Delete text from cursor until end of line              Ctrl+U      Discard all text on current line              Ctrl+F      Move cursor forward one character              Ctrl+B      Move cursor back one character              Ctrl+L      Clear screen      Exceptions and TracebacksIPython will by default print a full call stack trace if an exception is raised.The amount of context shown can be controlled using the %xmode magic command.Magic commands            Command      Description                  %quickref      Display the IPython Quick Reference Card              %magic      Display detailed documentation for all of the available magic commands              %debug      Enter the interaction debugger at the bottom of the last exception traceback              %hist      Print command input (and optionally output) history              %pdb      Automatically enter debugger after any exception              %paste      Execute pre-formatted Python code from clipboard              %cpaste      Open a special prompt for manually pasting Python code to be executed              %reset      Delete all variables/ names defined in interactive namespace              %page OBJECT      Pretty print the object and display it through a paper              %run script.py      Run a Python script inside IPython              %prun statement      Execute statement with cProfile and report the profiler output              %time statment      Report the execution time of single statement              %timeit statement      Run a statement multiple times to compute an emsemble average execution time. Useful for timing code with very short execution time              %who, %who_ls, %whos      Display variables defined in interactive namespace, with varying levels of information/verbosity              %xdel variable      Delete a variable and attempt to clear any references to the object in the IPython internals      Qt-based Rich GUI Consoleipython qtconsle --pylab=inline","categories": ["工具"],
        "tags": ["Python","IPython"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/Ipython/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "线性回归",
        "excerpt":"几乎所有的机器学习书籍都以线性回归为起点，这是有道理的。第一，线性回归比较容易入门，第二，线性回归是后续很多现代算法的基础，第三，线性回归是一种应用非常广泛的算法。简单线性回归的模型很简单，可以下面的公式表示：其中称为参数或权重。上式实现从X空间到Y空间的映射。拟合程度的好坏可以用下面的函数表示：被称为损失函数，这里的损失函数用估计值与实际值差的平方和来表示，是一种最常见的表示误差的方法。我们的目标就是使这个损失函数降到最小，实现最佳拟合。求最小二乘常用的有梯度下降法和举证计算法。梯度下降法梯度下降法的本质就是用迭代的思想，每一次都沿着最陡的方向（梯度）下降一小步，最终到达最小值。注意梯度下降法本身只能求局部最优解，但由于线性回归的J是个凸二次函数，因此局部最小值就是全局最小值。先对给出一个原始猜测值（一般可以取0），然后执行下面的迭代，其中是个固定值，称为学习率：对求偏导可得下式：所以有最终迭代的方程：直观理解，二次函数的导数就是个一次函数，沿着导数方向下降，就是上面这式子。上述式子是在只有一个训练样本时的情况，实际肯定会有大量的训练样本。对于多个训练样本，可以有两种变式。第一种方法叫批梯度下降，每一次迭代时，我把所有训练样本的误差都跑一遍，叠加后对进行更新。另一种方法叫随机梯度下降，每跑一个样本，我就迭代一次。显然随机梯度下降会比批梯度下降跑的快，由于每一次迭代都要计算所有样本，批梯度非常耗时。另一方面，随机梯度很可能无法达到最小值，而是在最小值左右徘徊。因此对大数据集我们倾向于选择随机梯度，而对于小数据集则选择批梯度。标准方程法对于损失函数最小值的求解，除了上面的梯度下降法，还可以用矩阵直接进行计算。但其过程涉及到很多的矩阵推导，需要具备较高的数学基础。这种算法的本质就是利用了函数最小值处导数等于0的性质。把上面的损失函数向量化，就是下面的表达式：将上面的损失函数对求导，可以得到：上述推导利用了矩阵的迹及相关性质，另篇专述。令等式等于0，可以得到：容易求出：注意当训练集和特征值很多时，求矩阵的逆会很耗时，此时算法的性能不如前面的梯度下降法。概率解释这一节从概率的角度出发，论证了为什么把最小二乘作为损失函数是令人信服的选择。个人觉得这是一个比较有趣的角度。假设我们的模型估计值和y真实值存在一个偏差，表示未被模型考虑的因素或者是随机的噪音。进一步假设是独立同分布的，服从的高斯分布：似然性函数等于：根据最大似然性准则，我们需要选择使似然性函数取到最大值。两边同取log函数，得到对数似然性函数：可以看出为了让最大，必须让最小，这就是前面的损失函数。还可以发现的取值和是无关的。需要注意的是最小二乘并不是唯一合理的损失函数，最大似然性作为一种假设也不是推导损失函数的必要条件。我们还有其他合理的损失函数可以选择。局部加权线性回归局部加权线性回归的本质在于考虑了预测样本，对于训练集中和预测样本相似的训练样本，给予其更高的权值。局部加权线性回归修改了简单线性回归的损失函数，添加了一个权值函数：这个权值函数又是和预测样本相关联的，下面是一种标准的选择，x是预测样本的输入，称为带宽，可以调整：局部加权线性回归显然是一种比简单线性回归优化的算法，但他也被称为非参数算法，因为模型参数会随着预测样本变化，因此需要每一次进行即时计算。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/linear-reg/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "逻辑回归",
        "excerpt":"线性回归是一种连续型模型，对于y值是离散的情况就无能为力了。对于分类问题而言，很常用的是另一种算法：逻辑回归。逻辑回归虽然是名为回归，实际却是解决分类问题的，这也是有趣的地方。我们这里仅限讨论二元分类，对于多元分类，原理一致。分类与逻辑回归在逻辑回归中，由于y取值只有0和1两种可能性，很自然的一个做法是先把X做一个映射，映射到（0，1）空间，而logistic函数很好的满足了这个性质：两侧很快的趋于边界。（注意logistic也不是唯一的选择）逻辑回归的模型就是在线性回归外又做了一个logistic计算：对于离散情况我们不能再用损失函数去衡量模型的拟合度，只能从最大似然性角度去衡量。逻辑回归和线性回归的似然性表示也有很大区别，线性回归通过引入一个误差的高斯分布来表示，逻辑回归则可以直接用来表示：把两式归纳起来可以写成：所以有最大似然函数：后面的套路都是一样的，两边求对数，用梯度下降法求对数最大似然函数最大值。对数最大似然函数：对于单个训练集来说，对其对数最大似然函数求导：利用增量梯度下降法：这个式子和线性回归竟然一模一样！当然这里的是不同的，其实后面可以证明，这可不仅仅是巧合哦。题外话：感知机感知机是个历史悠久的模型，刚开始用来模型神经元的原理。后来被用在机器学习中，虽然简单，但却非常有效。至今仍是神经网络算法的基石。感知机和逻辑回归不同的地方在于把logistic函数用域函数替代了：仍然使用上面的梯度下降法进行迭代。乍看之下感知机和逻辑回归非常相像，其实有很多的区别。感知机模型的输出也是离散量，而逻辑回归的输出是连续量。特别的，感知机没法用概率去解释，黑白分明，自然也没法用最大似然函数去衡量拟合情况。牛顿法牛顿法是另一种可以求解对数似然函数最大值得方法。注意牛顿法也必须应用在凸函数上。想要求得，可以用下式迭代：使用在求最大值上，即，则使用下式迭代：对于向量化的，比较复杂，需要使用到海森矩阵（一个1+n,1+n的矩阵）：海森矩阵（一个1+n,1+n的矩阵）的计算方法如下，还是另篇专述：牛顿方法通常比梯度下降法更快的收敛，这个可以从他们的迭代步子中也可以粗略的感知。但和直接计算法类似，牛顿法也使用了矩阵的逆，当特征数很大时，这一步的计算会很费时。所以，天下没有免费的午餐。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/logistic-reg/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "矩阵参考",
        "excerpt":"矩阵运算是各类算法的基础，虽然大学的线代都学过，但不用则废，现在还是需要捡起来。知识点略多，之前已经过了一遍，至于总结，准备采取需要什么总结什么的方式。增量补充吧，哈哈。单位矩阵单位矩阵就是对角为1，其余为0的矩阵，常常用作无中生有，当一个路人甲。因为它的脾气好：转置矩阵所谓的转置就是行列互换，转置的产生，往往是由于运算的需要。比如向量的平方和表示。转置有如下三个性质：  ：  ：  ：其中第一第三条很明显，第二条略作证明。迹矩阵的迹是方形矩阵的对角和，虽然它本身没什么作用，但常常被用作推演的中间步骤。对于迹，有如下五个性质：  For   For   For   For   For , and so on以上性质中，第1，2，3条都是显而易见的，第五条可以由第四条推导得到，因此只需要证明第4条。梯度梯度就是函数对矩阵求偏导，结果和原矩阵形状相同。梯度在机器学习中极为常用，需要牢牢掌握。梯度原始的性质只有简单的两条：  ：  ：For 但梯度还有其他延伸的性质，之前在线性规划推导直接计算法时就用到过。  ：  ：  ：下面分别予以证明：海森矩阵一个粗略的类比是，梯度是对矩阵求一阶导，海森是对向量求二阶导。这样方便我们理解海森的实质。有一个式子可以表达这个概念：注意第二次求导实际上是对每一个元素求导。因为没有定义向量的求导运算。海森矩阵是一个对称矩阵。即。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","数学基础"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/matrix-ref/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "广义线性模型",
        "excerpt":"这一章讲讲广义线性模型。我刚看到这一章的时候，觉得很神奇。知识的境界不就是归一么。能把具体的模型一般化了，这本身就是件美丽的事。这里就是把线性回归和逻辑回归都归入了广义线性模型（GLMs)。指数分布族在讲广义线性模型前，需要先了解指数分布族。凡是能表达成下面的形式的，都属于指数分布族。其中被称为自然参数，是充分统计量，对机器学习来说一般，是对数部分函数，其作用是做一个正态化常量。下面可以证明伯努利分布和高斯分布都属于指数分布族。因此有，得到。其他几个参数也水到渠成：对于高斯分布而言，因为对于最终的结果没有影响，因此取。因此有：此外还有多种分布也是属于指数分布族：  多项式分布：多个离散输出建模  泊松分布：对计数过程建模  伽马分布和指数分布：对连续非负随机变量建模，如时间间隔  贝塔分布和狄利克雷分布：对概率分布建模这么一看上次总结的七个分布完全不够用啊，逃~构建广义线性模型针对分类问题或回归问题，需要构造一个关于x的函数来预测y的值。满足三个假设可以构建广义线性模型：   即y的分布要满足某些指数分布族。  给定x，目标是预测的期望值，大多数情况下即y的期望值。。  自然参数和输入x成线性关系：这三个假说很容易理解，下面对线性回归和逻辑回归的推导也应用了三个假说，同时也证明了我们的构造的正确性。线性回归对于线性回归而言，其满足高斯分布，预测函数构造如下：逻辑回归对于逻辑回归而言，其满足伯努利分布，预测函数构造如下：所以，前面逻辑回归时用逻辑斯蒂函数不是没有道理的。Softmax 回归Softmax回归是逻辑回归的一般化，当输出有k个离散值时，y呈多项式分布，可以用Softmax回归刻画。y可以取k个值，每一个取值的概率为，但实际上这k个概率不是相互独立的，。为把多项式分布表示成指数分布族，定义，而不再是y了：用一种新的表达式来表示上式，。我们可以开始证明Softmax分布也是指数分布族的一种了：可以得出指数分布族的各参数：下面需要推导从到的映射。由上面可知，，同时定义。上面的表达式可以求解，，这个从到的映射函数称为softmax函数。和x还是线性关系，，其中是我们模型的参数，定义，则，因此分布概率可表达成下式：我们的预测函数则可以表达为下式：最后讨论一下参数拟合。还是采用和逻辑回归同样的方法，求最大似然函数的最大值，可以使用梯度下降法或牛顿法：","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/glm/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "随机分布",
        "excerpt":"随机分布属于概率统计的内容，同样在机器学习中经常遇到，线性回归被视为高斯分布，逻辑回归则是伯努利分布，因此在这里专列一篇介绍七个常见的随机分布，分成离散随机分布和连续随机分布两大块。离散随机分布介绍四种离散随机分布，分别是伯努利分布，二项分布，几何分布和泊松分布。离散随机分布用概率表达。伯努利分布伯努利分布是最简单的一种分布，抛一枚头向上概率为p的硬币，最终结果的分布。：二项分布独立抛n次头向上概率为p的硬币，最终有x次头向上的概率。：几何分布连续抛头向上概率为p的硬币，直到第x次头向上的概率。：泊松分布终于到了泊松分布，说实话这个分布一直听到，却一直没有了解其本质。这里先给出泊松分布的公式，再尝试做一个推导，加深一下对泊松分布的理解。：泊松分布可以从二项分布推演出来。在二项分布中，期望，在p固定的情况下，会随着n的增大而增大。现在考虑期望固定，n无限大的情况，二项分布的公式就会发生很大的变化：泊松分布必须满足下面三个性质，和上面的假设和推导相互印证。  任意单位时间长度内，到达率稳定。即固定。  未来与过去无关。即n永远为无穷次。  在极小的时间内，1次发生的概率很小，0次发生的概率很大。即p很小。连续随机分布介绍三种连续随机分布，分别是均匀分布，指数分布和正态分布。注意连续分布是用概率密度表示的。均匀分布均匀分布也好理解，在取值区间内概率相等。：指数分布指数分布是另一个神奇的分布，它和泊松分布是一对好基友。先给出表达式，后面再给解释。：当泊松分布用来衡量事件随时间分布时，指数分布可以用来描述事件间时间段长度。令，表示单位时间的平均到达率。此时，在t时间内一次都没发生的概率是，因此事件发生的概率是：事件间时长描述可求导得到：这就是我们的指数分布！同时我们也注意到两个分布原表达式中的是不一致的。也难怪，前者是用来表达概率的，后者是用来表达概率密度的。正态分布正态分布是老相识了，也就是高斯分布。正态分布也有很多神奇的性质，限于时间，下次有机会再写。：七种常见的随机分布暂时写到这里，其实还有很多可以补充。比如图表，均值和方差。这点内容花了我两个半小时，水还是深啊。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","数学基础"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/random/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "生成学习算法",
        "excerpt":"前面的回归算法和感知机算法都属于判别学习算法，这一章聊聊另一类算法：生成学习算法。这两者的区别可以用以下的比喻，判别学习算法是根据所有猫猫狗狗的特征，建立一个模型，区分出两类动物的分界线。生成学习算法则是分别对猫和狗建立一个模型，然后去对照看跟哪个模型更像。生成学习算法的理论依据就是贝叶斯公式，体现了后验概率和先验概率之间的关系：对于生成学习算法而言，实际分母一致，不需要计算，只需要比较分子大小：高斯判别分析当假设分布遵循多元正态分布时，我们可以使用高斯判别分析算法。在这之前先简要介绍多元正态分布。多元正态分布当正态分布从一元拓展到多元时，正态分布概率密度函数也需要做出相应的改变：其中， 是一个平均数向量，是一个协方差矩阵。粗略一看，多元正态分布的表达式和一元正态分布还是有几分神似的。高斯判别分布模型对于二元分类问题，满足以下假设时可以使用高斯判别分布模型：即下列分布函数：注意两个多元正态分布的平均数向量不同，协方差矩阵是一致的。然后我们就可以求解最大似然函数了：各参数可解得：高斯判别分布和逻辑回归从高斯判别分布可以推出逻辑回归（表问我怎么推~）：实际上高斯判别分布应用了更强的假设，即是一个多元高斯分布。因此可以从高斯判别分布可以推导到逻辑回归，但满足逻辑回归的不一定满足高斯判别分布，比如泊松判别分布也能推导到高斯分布。这也造成了高斯判别分布的性质，当原始数据吻合高斯分布时，这是一种很有效很精确的算法。但更多时候数据不能很好的满足高斯分布，这时候高斯判别分布就失效了，相比而言，逻辑回归更稳定，也更常用。朴素贝叶斯朴素贝叶斯是个大名鼎鼎的算法，不同于高斯判别分布应用于连续型输入，朴素贝叶斯应用于离散型输入，其最常用于文本分类中，比如判别是否为垃圾邮件。在文本分类中，一张词汇表作为一个特征向量，文本中含这个词则为1，不含则为0，最后的结果示例如下：要实现朴素贝叶斯算法，需要朴素贝叶斯假设成立。即特征值取值概率是完全相互独立的：即使建立在这种强假设上，朴素贝叶斯经常很好使。根据贝叶斯法则，需要确定的模型参数有。计算最大似然函数：求最大值可以解出各参数值。表示与运算，两边都满足才为真。这三个表达式其实都很直观，就是计数。总数里为1占得比例。预测函数也可以给出来：对于连续型输入，也可以通过分段处理来离散化，然后使用朴素贝叶斯算法。朴素贝叶斯算法这一块缺少实践感悟，后续需要再来研究。拉普拉斯平滑处理朴素贝叶斯算法存在一个问题，对于稀疏数据敏感。比如文本分类时有从未出现过的词，则这样计算就会出问题，换一个角度，从未出现过的词不代表以后也不会出现。因此简单把其概率置为0是不合理的。对于多元分类问题，假设z取值{1,…,k}，进行m次独立观察，则根据朴素贝叶斯算法：利用拉普拉斯平滑处理，可以解决这个问题，保证了每种情况至少有一个大于0的概率。同时保证。回头看上一节的垃圾邮件朴素贝叶斯，应用拉普拉斯平滑处理后：注意在垃圾邮件的实践应用中，可以不用拉普拉斯平滑处理，因为一般正常邮件和垃圾邮件会有一个比较合理的比例。不可能出现为0的情况。文本分类事件模型前面使用的朴素贝叶斯模型被称为多元伯努利事件模型，在文本分类中，还有另一种针对邮件而不是词汇表处理的朴素贝叶斯模型，称为多项式事件模型。我们让表示邮件中第i个词，在{1,…, }中取值， 代表词汇表大小。每一个词取值可能性相同，即满足多项式分布。模型的参数有，对于训练集代表第i个训练集中单词总量。得出最大似然函数：求最大值求解得到：对其使用拉普拉斯平滑：朴素贝叶斯不是最好的分类方法，但常常很有效。由于其简洁简单，朴素贝叶斯经常值得一试。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/generative-learning/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "支持向量机",
        "excerpt":"这一章主要学习支持向量机。支持向量机是目前最好的监督学习算法之一。但支持向量机本身难度较大，需要较强的数学基础。假如抛开数学部分，其本质就是用拉格朗日对偶法计算最大间隔，利用核函数简化高维映射的计算，用SMO算法更新参数。本文也将根据NG讲义的这一顺序展开。此外，这里有一份比较完善的中文入门资料。间隔入门回顾之前的逻辑回归，，当时预测为1，否则为0。这里存在一个预测的可信度问题，假如或者，那么预测的可信度就高。换一个角度，预测点离分割面越远，预测可信度就越高。把训练集离分割面最近的点到分割面的距离称为间隔，支持向量机的使命就是找到有最大间隔得分割面，使预测可信度提到最高。标记为了讨论支持向量机，需要引入一套新的标记符号。而不再是。分类器的表示也发生了变化：这里用的g是感知机算法，即，否则取-1。b是单独的截距，即之前的。函数间隔和几何间隔根据一个训练样本，定义函数间隔如下：函数间隔越大，可信度就越高。给定训练集，定义函数间隔是所有函数间隔中最小的那个：下面的问题是如何找出的表达式，分割面与永远是正交的。对于训练样本在分割面上的投影，可以表示成又因为投影点在分割面上，所以有：解得：结合y的取值可以得到几何间隔：我们发现几何间隔与函数间隔相比只是除了，当时函数间隔等于几何间隔。而且几何间隔不会受到比例系数的影响。最优间隔分类器对于一个可以线性分割的训练集来说，现在我们的任务就是要找到一个最大几何间隔。问题就转化成下面的优化问题：对于这样的约束条件很难处理，把几何间隔用函数间隔替换了，优化问题转化为：进一步，利用的可伸缩性质，令，求相当于求的最小值。现在优化问题转变成了一个凸二次函数带一个线性约束，这样的优化问题可以用QP软件来处理。拉格朗日对偶我们到了支持向量机的难点之一，拉格朗日对偶。这其实就是一种把多元约束优化问题转换为一元约束优化问题的思想。考虑下面这样的问题形式：我们定义拉格朗日公式为：这里被称为拉格朗日算子。通过求偏导可以求解得到和：将上面的形式进行拓展，把不等约束也包含在内，考虑下面的问题形式，称为原始优化问题：为了解决上述问题，我们定义了一般化的拉格朗日方程：考虑以下方程：假如 或者，都会使得考虑最小化问题：这就是我们的原始优化问题。最后定义优化值，称为原始问题的值。再来看一个有些不同的问题。定义：我们可以得到对偶优化问题：对偶优化问题相当于和初始优化问题交换了max和min的顺序，我们定义对偶优化问题的优化值为关于max和min有下面的结论：简要证明：对于任意x,y，下式成立：因此下式成立，得到证明：回到我们的拉格朗日对偶问题：在满足一定的条件下，上式中等号成立，因此我们可以用求解对偶问题来求解原始问题。假设和是凸函数，是线性的，约束是可满足的。那必然会存在满足，他们满足下面的KKT条件：相反的，假如存在满足KKT条件，那它也是拉格朗日问题的解。在KKT条件的第三式中我们还发现，必须满足当。（本来以为拉格朗日对偶会很困难，啃下来发现更多的是心理作用，233）优化间隔分类器回到我们的优化间隔分类器，我们可以把约束写成标准形式：根据KKT条件，只有在函数间隔是1时才能。实际上只有很少量的点决定了最大间隔。这些点被称为支持向量。把优化问题写成下面的拉格朗日形式，注意我们这里不带：我们首先找出拉格朗日对偶问题，即先固定，求对于的最小值。分别求对的偏导：由此得到：对b求偏导，我们得到：将代回表达式，我们得到：最终，我们得到下面的拉格朗日对偶问题：因为我们满足KKT条件，因此可以通过解答拉格朗日对偶问题来解决原始问题。对偶问题需要用下面的核函数解决。在得到后，也就能得到，可以通过下式得到：进一步讨论一下预测问题，对于新输入的x，我们要计算：我们注意到预测时也只用到了x的内积，对偶问题中同样只用了内积。此外，只有支持向量的不为0，因此这一步运算花费很少。核函数在房价预测中，我们用来得到一个三次方函数。这里我们把原始称为属性，把称为特征。用记为特征映射。在我们的例子里，有：将内积用代替，定义对应的核函数为：巧妙的地方在于可能的计算量很大，但却很容易。实际在算法中我们只需要应用到，却不必知道是多少。举下面两个例子。考虑核函数：因此特征映射函数为下式，需要时间，而核函数只需要：再考虑一个相关的核函数：此时的特征函数为：更一般的，核函数把特征映射到了维特征空间。需要时间，而核函数仍只需要。从另一个角度粗略的讲，体现了和之间的接近关系，越接近核函数越大，越远离核函数越小。比如下面的高斯核函数，很好的衡量了x和z之间的关系：但现在有一个问题，我怎么知道这个核函数是有意义的，即能找出特征映射满足。假设K是一个有效的核函数，给定有限点集，令一个核函数矩阵。假如K是个有效核函数，则有：还能证明核函数矩阵是半正定的：因此当核函数是有效的，核函数矩阵是对称半正定的。事实上这不仅仅是一个必要条件，还是一个充分条件。归纳为Mercer定理。除了应用在支持向量机中，核函数还在其他算法中大量应用。这种应用被称为核方法。（个人粗浅的理解，核方法看起来像是小技巧，实际上体现事物的内在本质）。规则化和不可分情况之前推导支持向量机时我们假定数据是线性可分割的，通过特征映射我们也能完成非线性分割，但有时候仍然会发生训练结果不好的情况，因为数据中会有噪音或离群点影响。为此，我们引入规则化和松弛变量，将优化问题转化为下面的问题：构造拉格朗日方程：采用对求偏导的方法，可以得到对偶方程：我们注意到对偶方程和未引入松弛变量前几乎一致，除了取值范围有变化。因为根据KKT条件，还能得出以下结果：SMO算法SMO算法专门用来高效解决支持向量机中推导出来的拉格朗日对偶问题。在讨论SMO算法之前先讲讲坐标上升法。坐标上升法坐标上升法是另一种优化方法，类似于前面的梯度下降法和牛顿法。其实质是每次只在一个坐标方向优化，考虑以下的无约束优化问题：使用以下的算法进行递归直到达到最优解：按顺序每一次固定其他，更新一个变量。（更复杂的版本是每一次更新使W增加最快的变量）。当函数W是类似于 arg max 这样高效运算的函数时，坐标上升法是一种很有效的算法。SMO我们回到SMO算法来解决拉格朗日对偶问题。观察约束，我们发现并不完全独立，。受坐标上升法的启发，SMO算法的核心就是选择一对参数（使W增长最快的两个）进行更新，直到优化结束。假设选择进行更新：结合的约束，的真实取值范围是。最终更新结果是：值可以通过前面的线性关系求得。SMO这里讲的还是比较粗略，需要后续再补充。不过支持向量机到此终于完结了，花了三天半时间，也是值得。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/SVM/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "机器学习原理",
        "excerpt":"偏差和方差还是从房价预测的例子入手，我们可以分别用一次函数，三次函数和五次函数去拟合测试集。但不是三个模型都是好模型，第一个和第三个都存在着泛化误差，即测试集的拟合误差要大于训练集的期望误差。对于一次函数模型，我们认为模型有偏差，即使给出足够大的训练集也会使数据欠拟合。而对于五次函数模型，我们认为模型有方差，仅仅是很好的吻合了小范围的测试集，对数据过拟合，不能准确反映更一般的输入输出关系。很多时候都需要在偏差和方差之间做权衡。假如我们的模型过于简单只有很少的几个参数，那很可能有大的偏差；假如模型过于复杂有很多的参数，那可能会有大的方差。预备知识我们开始学习一些机器学习原理中最基石的规则。最终希望能够回答三个问题：  我们是否可以把偏差和方差公式化？最终引出模型选择方法。  为何从测试集中可以获得泛化误差？测试集误差和泛化误差是否有联系？  是否能在某些条件下证明算法一定有效？首先介绍两个引理（这里没有证明，可以直观感受）。联合界定理：存在共k个不同事件（可能独立也可能非独立），必然有：霍夫丁不等式：令是m个服从伯努利分布的独立同分布随机变量，令作为随机变量的均值，令任意固定，有下面的关系：为了简化解释，我们再以二元分类为例。假设给定一个训练集，训练样本满足可能性分布，对于假说h，定义训练误差（经验误差）为：定义泛化误差为：PAC是一组构建机器学习原理的假定。其中最重要的两条就是训练集和测试集满足同分布，训练样本具备独立性。考虑线性分类，令，评估参数拟合的一种方式就是让训练误差最小化：这个过程被称为经验风险最小化，它被视为是最基础的学习算法。ERM本身是非凸不能用一般优化算法求解的，逻辑回归和支持向量机被看做对这种算法的凸性近似。更一般化，我们用假设集来定义一组分类器。比如对于线性分类法，。经验风险最小化可以写成下式：有限假设集我们先来考虑假说集有限的情况，即，假设集由k个假说构成。经验风险最小化算法选择其中使训练误差最小的假说作为。考虑一个伯努利随机变量Z，样本，令。对训练样本我们同样定义。训练样本和测试样本服从同分布。可以看到误分类的可能性就等于的期望值，此外，训练误差可表示成：因此我们在这里可以应用霍夫丁不等式：这显示了当m足够大时，对特定的训练误差有极高的可能性与泛化误差接近。下面我们要证明对于所有，上面的特性也成立。这个结果被称为一致收敛，对于所有h都满足。令，我们可以计算出为达到概率在，精确度在内要求所需的样本复杂度m：同样，我们也可以求得精确度：现在还有一个问题，模型的泛化误差和最小训练误差存在什么联系？令作为假设集中最好的一个，它与训练误差最小的假设存在以下关系：在，固定，至少有的可能性：这也从另一面证明了偏差和方差的矛盾性。假设我们的假设集扩大了，则前一项下降，后一项增加。反之亦然。无限假设集在有限假设集中我们得出了一些有用的定理。但对于参数是实数的假设集来说，有无限个假设。我们是否能得出类似的结论？首先做一个不是很正确的解释。因为实数在计算机中也是由有限位组成，因此所谓的无限假设实际上也是有限的，因此可以套用上一节的结论来处理。为得出无限假设集的结果，我们需要定义VC维。给定样本点集合，我们说粉碎假如可以识别任意的标签。我们定义VC维，是最大的可粉碎样本大小。例如对于有两个维度的线性分类而言，。下式展示了对于无限假设集的定理，对于给定，令，至少有的可能性：同样还有下面的结论：对 要求至少概率对所有成立，需要满足。即对于最小化训练误差的算法，所需的训练样本数和算法参数个数几乎成线性关系。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习理论"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine-learning-theory/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "规则化与模型选择",
        "excerpt":"对于有限个模型，我们如何选择最优的模型。交叉验证对于整个训练集进行训练，从中挑选最小训练误差来评价模型并不是一个好方法，因为这样往往选出高方差的模型。因此有下面的交叉验证法：把训练数据分S成和两部分，一般分成七三开。用来训练数据，用来验证数据。从中挑出验证误差最小的模型作为最优模型，再进行全数据集重训练。交叉验证避免了一味选择复杂的模型，但也造成了数据的浪费，特别在数据量不足时可能影响模型的训练精度。下面是一种更改良的方法，称为k折交叉验证。把数据集S分为k份，在评估某一个模型时，每一次将其中一份作为验证集，其他k-1份作为训练集，计算出平均的验证误差。最后挑选出最优模型进行全数据集重训练。交叉验证除了使用于模型选择上，还可用以评估单个模型的预测准确度上。特征选择有些时候会遇到特征过多的情况，这种情况下很容易造成过拟合。这时我们就需要采取特征选择算法来降低特征的数量。一种算法称为前向搜索。从零开始，每次增加一个特征，利用交叉验证计算误差，选择误差最小的增加，直到达到阈值。与之相对的另一种算法称为后向搜索。这两种算法的时间复杂度都比较高，需要。第二种算法称为过滤特征选择。本质就是简单计算每个特征和的相关度。选择得分最高的k个特征。在实际中，最常见的就是用互信息来衡量相关度：互信息还可以用KL距离来表示:最后一点是如何确定k的取值，标准做法就是采用交叉验证。贝叶斯统计和规则化回顾根据最大似然函数选择参数：从频率学派角度来看，不是随机的，而是确定而未知的值。我们的任务就是通过统计方法（比如最大似然函数）来找出它的值。从贝叶斯学派角度来看，是随机未知的值，我们可以给定一个先验分布，给定训练集，我们可以计算后验概率：这里的可以从学习模型中得到。比如对于贝叶斯逻辑回归而言，，其中给定新的测试样本，我们可以计算对于标签的后验概率：但事实上后验概率公式中的分母积分很难计算，我们常常最大后验概率估计代替，只比最大似然估计函数多了一个：在实际应用中,常常假定先验概率满足。贝叶斯最大后验概率估计往往比最大似然估计更容易克服过拟合问题。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习理论"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/model-selection/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "K均值聚类与混合高斯模型",
        "excerpt":"K均值聚类算法在聚类问题中，我们给定一个训练集，标签没有给出，我们的目标还是把数据分类。这是一个非监督学习问题。K均值聚类算法给出了下面的方法：  随机初始化聚类中心  不断迭代直到收敛：{对所有i，令：对所有j，令：}算法的内循环不停的在执行两个步骤，先把每个训练样本归给最近的聚类中心所代表的类，然后将某类的所有点计算平均值作为新的聚类中心。现在有一个问题，如何保证K均值聚类算法一定会收敛？定义失真函数为：失真函数定义了所有训练集离其聚类中心平方距离和。对于算法的内循环的两步而言，每一步都是朝着J下降的方向进行。实际上K均值聚类算法就是一类坐标下降法。最终J会达到收敛。失真函数J是一个非凸函数，所以坐标下降法不能保证J能收敛到全局最小值。为了不限于局部最小值，可以多次跑K均值聚类算法（使用不同的随机初始值），取最低失真函数。混合高斯模型同样假设下面的非监督学习问题，给定一组训练集，没有标签。我们用一个联合分布来对数据进行建模。这里，，。因此我们的模型是随机从中选择，然后从对应的高斯分布中选择。这被称为混合高斯模型。此外由于是潜在的随机变量，这使我们的评估变得困难。混合高斯模型的参数有，最大似然函数是：然而上式无法用梯度来计算，因此也无法解得最大似然估计。注意上式中产生的原因在于是未知的，假如是已知的，那么最大似然函数可以简化为：做最大似然估计可以解出：事实上，假如是已知的，那么最大似然估计和之前的高斯判别分析非常类似，只是表示了标签。然而是未知的，这里就引出了最大期望算法。最大期望算法主要由两步构成，E步尝试猜测的值，M步根据我们猜测的更新模型参数。迭代直到收敛：{（E步）对每个i,j，令：（M步）更新参数：}在E步，我们通过计算后验概率来得到：EM算法和K均值聚类算法有很多相似的地方，都是两步走，都是可能陷入局部最优解，需要多次不同的初始值进行计算。EM算法是否确保收敛等性质放到下一章证明。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Kmean-mix-gauss/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "技术博客搭建",
        "excerpt":"搭建一个属于自己的博客是我一直都有的梦想。作为一个有技术的人，当然应该选择gitpage。使用git来管理，用markdown来撰写，不担心内容丢失，也不用为繁杂的语法困扰，十分合我心意。下面就记录一下我的博客搭建过程，操作系统是OS X。申请gitpage账号，建立仓库。想要用gitpage，首先得有个github账号。github建立博客仓库在github上建立一个仓库，仓库命名是有规范的。比如我的github用户名是anyinlover，那么仓库必须命名为anyinlover.github.io。远程仓库同步到本地找个合适的文件夹防止本地目录，比如Documents下：git clone anyinlover.github.io假如还没有安装git，需要先装上git。安装jekyll并绑定文件夹安装jekyllgem install jekyll绑定文件夹cd anyinlover.github.iojekyll build安装配置模板网上有挺多jekyll模板，除了官方模板网站，我更喜欢dr. jekyll themes。如果要足够简单，poole是个不错的选择，本次我使用的是一位中国人做的模板hux，功能强大，在各方面都很趁意。安装模板从模板网站上把文件夹下载下来，解压到本地的博客文件夹。可以在本地打开jekyll先看一下，在浏览器输入0.0.0.0:4000：jekyll serve配置模板配置模板是件比较烦的事情。特别是hux这个模板，虽然好看，但也意味着可配置的东西太多。配置文件主要是_config.xml这个文件，其他地方就需要修改html代码了。配置_config.xml前面的title啥的不必提了，看几个特别的地方。SNS设置那里我添加了豆瓣和简书的支持。增加douban_username和jianshu_username两行。anchorjs那里我把默认的true改成了false，因为正文中标题前莫名出现一个#看起来很难受，锚定的功能也用不上。评论系统我选择了disqus，注释了默认的duoshuo。kramdown那里作者配置了输入GFM，我也把它去掉了，我需要用latex语法输入数学公式，这是GFM不支持的。配置about.html作者把about.html直接写成了html，我觉得更合适的还是用md文件来表示。修改其中的description，删除秀恩爱照片。在正文中去掉了中英文版本（按钮略丑）。替换内容，只留下一段自己的介绍。配置index.html和tags.html作者把这两页的描述都写进了html文件里，打开修改成自己要说的description,删除默认图片配置page.html在page.html中添加了豆瓣和简书的支持，在143行插入：配置footer.html在footer.html中也要添加page.html里添加的代码。在最后的Theme by Hux，删去了github部分。撰写博客并上传撰写用macdown写博客，放在_posts文件夹下。需要有文件头类似如下：---layout: singletitle: \"技术博客搭建\"subtitle: \"感谢gitpage，jekyll和hux模板\"date: 2016-4-21author: \"Anyinlover\"category: truetags:  - 工具---上传git add *.mdgit commit -m \"add somefile\"git push origin master结尾好啦，博客搭建过程大概如此，现在让我们一块欣赏吧。","categories": ["工具"],
        "tags": ["jekyll","github"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/build-the-blog/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "最大期望算法",
        "excerpt":"在前一讲中，我们谈到最大期望算法应用于混合高斯模型中，在这一讲，我们给出最大期望算法的一般形式，展示其如何能运用于求解潜在变量的预测问题。琴生不等式假如是一个凸函数，即，或者。恒取大于号是称为严格凸函数。X是随机分布，琴生不等式可表达如下：当等号成立时必须有恒成立，即X是常量。琴生不等式可以用图形直观的去解释。同理，当f时一个凹函数时，不等式反向成立。最大期望算法给定训练集由m个独立样本构成。我们需要针对数据拟合模型的参数，最大似然函数由下式给出：对上式直接求偏导计算无法得到解析解。因为是一个潜在变量，只有是已知的条件下，才可能解出，因此引出了最大期望算法。它的策略就是分两步走，E步首先给出的下限，然后在M步优化这个下限。对每个i，令是对z的分布（）运用琴生不等式，有下面的关系：我们可以看出分布针对关于的期望值就是又由于对数函数是一个凹函数，因此有：因此对于任意分布，上式给出了对的下限。在选择时，一个很自然的做法是l令琴生不等式等号成立。即变量为常量：其中c是独立于的常量。又因为，所以有：也就是是在给定下的后验分布。现在我们可以得出最大期望算法的数学表达：重复下面的步骤直到收敛：{E步，对每个i，令：M步，令：}但我们如何能证明最大期望算法一定能收敛呢？通过下式可以得到：因此最大期望算法一定是逐渐收敛的，在实际应用中，我们常常是给定一个容忍系数来终止算法拟合。假如我们定义：最大期望算法可以被视作对于J的坐标上升法。在E步优化Q，在M步优化。混合高斯模型再回顾有了最大期望算法的一般定义，我们再回头来拟合混合高斯模型的参数。E步很简单：在M步，我们需要分别对参数求目标函数的最大化:首先来求解，对其求梯度可以得到：将上式等于0可以得到：再来考虑，我们需要最大化：但认识到并不是完全独立的，存在的关系，因此我们可以构造拉格朗日方程：求偏导我们得到：因此有：根据的约束关系，，最终我们可以得到：关于 也可以通过类似方法得到，不过让我自己推出来还是蛮困难的~","categories": ["机器学习"],
        "tags": ["机器学习算法","Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/em-algorithm/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "因子分析",
        "excerpt":"在前面的混合高斯模型中，我们常常假定我们有充足的样本去发现数据的内在结构。也就是样本数m远远大于特征数n。现在考虑的情况，在这样的条件下，单高斯模型都无法拟合，更不论混合高斯模型了。根据最大似然估计，高斯模型的拟合参数如下：我们会发现是奇异阵，不存在。这样就无法计算模型的密度函数了。进一步讲，要通过最大似然估计来拟合高斯模型，必须让m远大于n，才能有比较好的结果。那么我们如何解决这个样本数不足的问题呢？限制如果我们没有足够的数据来拟合一个协方差矩阵，我们可以为其添加一些限制。比如考虑协方差矩阵是对角的，也就是特征间是相互独立的，在这种情况下：二元高斯分布在平面的投影是个椭圆，对角阵意味着椭圆轴线与坐标轴平行。进一步，我们还能控制不仅是对角的，而且对角元素相同。，可以通过最大似然估计得到：在高斯分布平面投影上椭圆变成了圆。假如不对做限制，我们必须在的条件下才能保证不是一个奇异阵，在上面的约束下，只需要就能保证非奇异。但上述的假设太强，意味着特征之间完全相互独立，假如我们想要挖掘数据内部的关系时，就需要使用到因子分析模型。边缘和条件高斯分布在描述因子分析之前，我们先来讨论一下如何找到联合多元高斯分布的条件分布和边缘分布。假定我们有一个随机变量：这里 假定 ，有： 和被称为联合多元分布，那么的边缘分布是什么？很容易可以看到, 。因为根据协方差的定义：因此可以得出的边缘分布是。下面再来考虑在给定下的条件分布。可以记作，可以计算如下：因子分析模型在因子分析模型中，我们定义(x,z)的联合分布如下，其中是一个潜在随机变量：其中向量，矩阵 ， 对角阵，k的取值一般都要小于n。我们相当于把数据从k维映射到n维，最后再填上一个噪音。上面的因子分析模型也可以表示成下面的形式：我们的随机变量z，x构成了一个联合高斯分布：下面来找到和。容易直到，因为z满足标准正态分布。可有下式求解：因此可以得到:下面继续计算，因为，最终我们得到联合分布如下：x的边缘分布是，因此可以得出其最大似然函数的表达式：对于上述的最大似然函数估计，同样的无法直接求解，需要用最大期望算法来解决。因子分析的最大期望算法在E步，我们需要计算 z^{(i)} \\mid x^{(i)}; \\mu, \\Lambda, \\Psi \\sim \\mathcal{N} (\\mu_{z^{(i)} \\mid x^{(i)}}, \\Sigma_{z^{(i)} \\mid x^{(i)}})，其中：后面的推导偷懒不写了~一句话就是用EM算法去求解，感觉更多的是考验数学水平。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习理论"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/factor-analysis/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "逻辑回归习题",
        "excerpt":"逻辑回归证明逻辑回归的对数最大似然函数的海森矩阵是半负定矩阵对数最大似然函数表示如下：其一阶导根据讲义的证明是：海森矩阵单个元素可表示为：海森矩阵可表示为：下面来证明 恒成立。因此逻辑回归的对数最大似然函数的海森矩阵是一个半负定矩阵，其只有一个唯一的全局最大值。用牛顿法来拟合逻辑回归模型尽管牛顿法的表达式已经给出，但用python跑出这个程序还是花了我三个小时。主要的难点在于把前面的代数表示转化为矩阵表示，包括梯度和海森矩阵。下面给出我的python代码，用的是python3。from numpy import *import pandas as pdorx = pd.read_csv('q1x.dat', sep='\\s+', header=None).valuesy = pd.read_csv('q1y.dat', sep='\\s+', header=None).values.ravel()X = hstack((ones((orx.shape[0], 1)), orx))theta = zeros(X.shape[1])def h(theta):    return 1/(1+exp(-dot(X, theta)))def hd(theta):    return dot(X.T, y - h(theta))def hdd(theta):    return -dot(X.T, tile(h(theta)*(1-h(theta)), (theta.size, 1)).T*X)maxtry = 50for i in range(maxtry):    theta = theta - dot(linalg.inv(hdd(theta)), hd(theta))print(theta)画图这个纯粹的就是画图能力的考验，这一块前面看过《python machine learning》，还是比较容易的。import matplotlib.pyplot as pltplt.scatter(x = orx[y==1,0], y = orx[y==1,1], marker='o', color='red', label='y=1')plt.scatter(x = orx[y==0,0], y = orx[y==0,1], marker='x', color='blue', label='y=0')plt.xlabel('$x_1$')plt.ylabel('$x_2$')plt.legend(loc='upper left')plt.xlim(0,9)x1 = arange(0,10,1)x2 = (-theta[0]-theta[1]*x1)/theta[2]plt.plot(x1, x2)最后得到的图：","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/log-reg-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "局部加权回归习题",
        "excerpt":"加权系数的矩阵表示令，因此可以推导出下式：局部加权的标准方程根据上式得到的损失函数，可以计算如下：令上式为0，最终我们得出局部加权的标准方程为：以y的方差表示加权系数即：回归问题实现一般回归用标准方程来写一般回归是比较容易的。from numpy import *import pandas as pdorx = pd.read_csv('q2x.dat', sep = '\\s+', header=None).valuesy = pd.read_csv('q2y.dat', sep = '\\s+', header=None).values.ravel()X = hstack((ones((orx.shape[0],1)), orx))theta = dot(dot(linalg.inv(dot(X.T,X)), X.T),y)print(theta)import matplotlib.pyplot as pltplt.scatter(x = orx.ravel(), y = y, marker='x', color='blue')plt.xlabel('x')plt.ylabel('y')plt.xlim(-10,15)xl = arange(-10,16,1)yl = theta[0]+theta[1]*xlplt.plot(xl, yl)实现局部加权线性回归Xl = arange(-10, 15.01, 0.02)def plot_t(t):    plt.hold('on')    Xl = arange(-10, 15.01, 0.02)    Ylo = []    for xl in Xl:        w = exp(-(orx.ravel()-xl)**2/(2*t**2))        W = diag(w)        theta = dot(dot(dot(linalg.pinv(dot(dot(X.T,W),X)),X.T),W),y)        yl = dot(theta.T,array([1,xl]))        Ylo.append(yl)        Yl = array(Ylo)    plt.plot(Xl,Yl,color='red') plt.scatter(x = orx.ravel(), y = y, marker='x', color='blue')plt.xlabel('x')plt.ylabel('y')plt.xlim(-10,15)plot_t(0.8)plot_t(0.3)plot_t(2)最终的图形如下（这图还可以优化一下），局部线性回归可以较好的拟合散点。带宽的影响带宽决定了影响模型的样本数量多少。带宽越小，影响模型的样本越少，模型也更容易受噪音影响，上面当带宽变0.1时，直接导致矩阵不可逆。带宽越大，影响模型的样本越多，模型更趋于一般线性回归。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/local-reg-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "广义线性模型习题",
        "excerpt":"证明泊松分布属于指数分布族因此可以得到：泊松模型的正则响应函数泊松模型的随机梯度下降随机梯度上升的规则是：证明递归规则的通用性首先可以得出：因此只需要证明  即可得证。等式两边对求导：因此上面的递归规则具有通用性。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/glm-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "高斯判别分析习题",
        "excerpt":"高斯判别分析与逻辑回归的关系因此可以得到：模型参数推导然后分别对各参数求偏导。首先求解令上式为0，可以得到：再求解令上式为0，可以得到，同理：最后求解，为方便计算，对求偏导：令上式为0，可以得到：","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/gaussian-discriminant-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "优化算法线性不变习题",
        "excerpt":"证明牛顿法是线性不变的令，需要找到和的表示。上式等同于：其中是A的第i列。因此有：再来定义海森矩阵：因此有:下面来推导对于函数的牛顿方法：只需要证明，即完成证明：证明梯度下降法不是线性不变在上应用梯度下降规则：在$$f(x)%%上应用梯度下降规则：要使得 成立，必须在成立的条件下才能成立，因此梯度下降法不是线性不变的。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/linear-invariance-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Python速成",
        "excerpt":"得到python从python官网可以下载python，对于数据科学家来说，更方便的是直接下载Anaconda分发包。pip是python包管理工具，利用它可以很方便的寻找安装python包。Ipython是一个增强版的python shell。和它配套使用的还有一个jupyter notebook，有很好的交互界面，是我目前使用python的主力战场。python之禅下面描述了python之禅：python的设计原则，  Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one– and preferably only one –obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea – let’s do more of those!其中最常见得一条就是在python中只有一种最好的实现方法，常常被称为Pythonic。空格格式化python中用缩进来表示代码块。for i in [1, 2, 3, 4, 5]:    print(i)    for j in [1, 2, 3, 4, 5]:        print(j)        print(i+j)    print(i)print(\"done looping\")这让python代码非常具有可读性，但也因此需要注意空格的使用。空格在括号内是被忽略的，比如用在下面的长代码中：long_winded_computation=(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11                        + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20)或者让代码变得更加可读：list_of_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]easier_to_read_list_of_lists = [ [1, 2, 3],                                 [4, 5, 6],                                 [7, 8, 9] ]反斜杠可以用来断行，但一般很少用：two_plus_three = 2 + \\                 3使用空格的一个缺陷是代码复制时会变形，在Ipython中有一个函数%paste可以解决这个问题。模块python的很多功能都需要导入模块来实现。一种简单的方法是把模块整个导入：import remy_regex = re.compile(\"[0-9]+\", re.I)这样导入后只能通过加前缀re.来调用模块内的函数。如果代码中这个标识符已经被使用，可以用别名来替代：import re as regexmy_regex = regex.compile(\"[0-9]+\", regex.I)当模块名称不清晰或者过于冗长时，也可以用别名：import matplotlib.pyplot as plt如果只需要使用到模块中一些特定的子模块或函数，可以显性的导入：from collections import defaultdict, Counterlookup = defaultdict(int)my_counter = Counter()另外也有一种做法就是把模块内的值全都导入，但这样会有命名冲突的风险，不推荐这样处理，比如下面re.match覆盖了原来的match。match = 10from re import *print match算术在python2中除法是整数除法，到python3中已经是浮点数除法了。5/2再也不会等于2了。函数一个函数把输入转化成输出，在python中使用def来定义函数：def double(x):    \"\"\"this is where you put an optional docstring    that explains what the function does.    for example, this function multiplies its input by 2\"\"\"    return x * 2在python中函数是原始类的，也就是函数可以被赋给变量，也可以作为参数传给另一个函数。def apply_to_one(f):    \"\"\"calls the function f with 1 as its argument\"\"\"    return f(1)my_double = double # refers to the previously defined functionx = apply_to_one(my_double) # equals 2使用lambda语法可以创造匿名函数：y = apply_to_one(lambda x: x + 4) # equals 5lambda函数也能赋给变量，但多数人推荐下面的传统做法：another_double = lambda x: 2 * x # don't do thisdef another_double(x): return 2 * x # do this instead函数参数可以指定默认值：def my_print(message=\"my default message\"):    print(message)my_print(\"hello\") # prints 'hello'my_print()\t\t # prints 'my default message'传参时带上变量名有时候也很有用：def subtract(a=0, b=0):    return a - bsubtract(10, 5) # returns 5subtract(0, 5)  # returns -5subtract(b=10)  # same as previous字符串字符串可以用单引号或双引号来定义：single_quoted_string='data science'double_quoted_string=\"data science\"python使用反斜杠来编码特殊字符：tab_string = \"\\t\" # represents the tab characterlen(tab_string)如果仍然想让反斜杠保持为反斜杠，可以用r\"\"创造原始字符串：not_tab_string=r\"\\t\" # represents the characters '\\' and 't'len(not_tab_string)可以三个双引号来创建多行的字符串：muti_line_string = \"\"\"This is the first line.and this is the second lineand this is the third line\"\"\"异常在python中可以用try和except来处理异常，防止程序报错：try:    print(0/0)except ZeroDivisionError:    print(\"cannot divide by zero\")虽然在很多语言中异常被认为是不好的，但在python中偶尔的使用异常可让代码保持整洁。列表列表是python中最基础的数据结构。列表是一个有序集合。integer_list = [1, 2, 3]heterogeneous_list = [\"string\", 0.1, True]list_of_lists = [ integer_list, heterogeneous_list, []]list_length = len(integer_list) # equals 3list_sum = sum(integer_list) # equals 6可以用方括号来对第n个元素取值或赋值x = list(range(10)) # is the list [0, 1, ..., 9]zero = x[0] # equals 0, lists are 0-indexedone = x[1] # equals 1nine = x[-1] # equals 9, 'Pythonic' for last elementeight = x[-2] # equals 8, 'Pythonic' for next-to-last elementx[0] = -1 # now x is [-1, 1, 2, 3, ..., 9]方括号也可以用来切片：first_three = x[:3] # [-1, 1, 2]three_to_end = x[3:] # [3, 4, ..., 9]one_to_four = x[1:5] # [1, 2, 3, 4]last_three = x[-3:] # [7, 8, 9]without_first_and_last = x[1:-1] # [1, 2, ..., 8]copy_of_x = x[:] # [-1, 1, 2, ..., 9]python有一个in操作来验证元素是否在列表中：1 in [1, 2, 3] # True0 in [1, 2, 3] # False这个操作会依次去进行比较，除非列表比较短，否则会很费时。把列表串联起来是容易的：x = [1, 2, 3]x.extend([4, 5, 6]) # x is now [1,2,3,4,5,6]如果不想改变x那么可以采用列表加法：x = [1, 2, 3]y = x + [4, 5, 6] # y is [1,2,3,4,5,6]; x is unchanged最常见的还是每次添加一个元素：x = [1, 2, 3]x.append(0) # x is now [1, 2, 3, 0]y = x[-1] # equals 0z = len(x) # equals 4如果知道列表元素个数还可以使用解包：x, y = [1, 2] # now x is 1, y is 2对于不需要使用的元素可以用下划线替代：_, y = [1, 2] # now y==2, didn't care about the first element元组元组与列表类似，但是不可变的。列表很多不涉及到修改元素的操作都可以用在元组上。元组用小括号来表示：my_list = [1, 2]my_tuple = (1, 2)other_tuple = 3, 4my_list[1] = 3 # my_list is now [1, 3]try:    my_tuple[1] = 3except TypeError:    print(\"cannot modify a tuple\")元组可以被用来从函数返回多值。def sum_and_product(x, y):    return (x+y), (x*y)sp = sum_and_product(2, 3) # equals (5, 6)s, p = sum_and_product(5, 10) # s is 15, p is 50元组和列表都可以用来赋多值：x, y = 1, 2 # now x is 1, y is 2x, y = y, x # Pythonic way to swap variables; now x is 2, y is 1字典字典是另一种基本数据结构，将键和值相对应，方便快速查找。empty_dict = {} # Pythonicempty_dict2 = dict() # less Pythonicgrades = {\"Joel\": 80, \"Tim\": 95} # dictionary literal可以通过键来查找值。joels_grade = grades[\"Joel\"] # equals 80假如键不在字典中，就会报错KeyError：try:    kates_grade = grades[\"Kate\"]except KeyError:    print(\"no grad for Kate!\")可以用下面的方法检查键是否存在：joel_has_grade = \"Joel\" in grades # Truekate_has_grade = \"Kate\" in grades # False字典有一个get方法可以在键不存在时返回一个默认值：joels_grade = grades.get(\"Joel\", 0) # equals 80kates_grade = grades.get(\"Kate\", 0) # equals 0no_ones_grade = grades.get(\"No One\") # default default is None用中括号可以对键赋值：grades[\"Tim\"] = 99 # replaces the old valuegrades[\"Kate\"] = 100 # adds a third entrynum_students = len(grades) # equals 3字典可以很方便的表示结构性数据：tweet = {    \"user\" : \"joelgrus\",    \"text\" : \"Data Science is Awesome\",    \"retweet_count\" : 100,    \"hashtags\" : [\"#data\", \"#science\", \"#datascience\",                  \"#awesome\", \"#yolo\"]}除了查找特定的键，还可以查找下面的值：tweet_keys = tweet.keys() # list of keystweet_values = tweet.values() # list of valuestweet_items = tweet.items() # list of (key, value) tuples\"user\" in tweet_keys # True, but uses a slow list in\"user\" in tweet # more Pythonic, uses faster dict in\"joelgrus\" in tweet_values字典的键必须是不可变得，因此，不能将列表作为键，如果需要多键，可以使用元组或者把键转化成字符串。默认字典假如需要对文档的单词进行计数，常规的方法如下：document = \"Hello how are you. Every one has a mi ring\"word_counts = {}for word in document:    if word in word_counts:        word_counts[word] += 1    else:        word_counts[word] = 1word_counts或者使用异常机制来处理首次添加：word_counts = {}for word in document:    try:        word_counts[word] += 1    except KeyError:        word_counts[word] = 1第三种方法是使用get方法：word_counts = {}for word in document:    previous_count = word_counts.get(word, 0)    word_counts[word] = previous_count + 1但这三种方法看起来都有些别扭，更好的方法是使用defaultdict。from collections import defaultdictword_counts = defaultdict(int) # int() produces 0for word in document:    word_counts[word] += 1除了应用在整数上，还能应用在列表或字典，甚至自己的函数上：dd_list = defaultdict(list) # list() produces an empty listdd_list[2].append(1) # now dd_list contains {2: [1]}dd_dict = defaultdict(dict) # dict() produces an empty dictdd_dict[\"Joel\"][\"City\"] = \"Seattle\" # {\"Joel\": {\"City\":\"Seattle\"}}dd_pair = defaultdict(lambda: [0, 0])dd_pair[2][1] = 1 # {2: [0,1]}所以这是一种很方便的省却检查键是否存在的解决方案。计数计数构造了一个字典，并将键映射到个数：from collections import Counterc = Counter([0, 1, 2, 0]) # c is (basically) {0:2, 1:1, 2:1}因此这可以方便的解决我们的单词统计问题：word_counts = Counter(document)计数示例有一个most_common方法很有效：# print the 10 most common words and their countsfor word, count in word_counts.most_common(10):    print(word, count)集合集合是另一种数据结构，表达了离散元素的集合。s = set()s.add(1) # s is now { 1 }s.add(2) # s is now {1, 2}s.add(2) # s is still { 1, 2}x = len(s) # equals 2y = 2 in s # equals Truez = 3 in s # equals False使用集合主要有两个理由。第一个是in操作在集合中应用非常快，类似于字典中键的查找：stopwords_list = [\"a\",\"an\",\"at\"] + [\"manyotherwords\"] + [\"yet\", \"you\"]\"zip\" in stopwords_list # False, but have to check every elementstopwords_set = set(stopwords_list)\"zip\" in stopwords_set # very fast to check第二个理由是找到集合中不同项：item_list = [1, 2, 3, 1, 2, 3]num_items = len(item_list) # 6item_set = set(item_list)  # {1，2，3}num_distinct_items = len(item_set) # 3distinct_items = list(item_set) # [1, 2, 3]集合比字典和列表使用的少得多。控制流像大部分编程语言，python可以使用if：if 1 &gt; 2:    message = \"if only 1 were greater than two...\"elif 1 &gt; 3:    message = \"elif stands for 'else if'\"else:    message = \"when all else fails use else (if you want to)\"有时候还可以写成一行：parity = \"even\" if x % 2 == 0 else \"odd\"Python还有一个while循环：x = 0while x &lt; 10:    print(x, \"is less than 10\")    x += 1但更常用的是for和in：for x in range(10):    print(x, \"is less than 10\")如果要控制更复杂的逻辑，可以使用continue和break：for x in range(10):    if x == 3:        continue # go immediately to the next iteration    if x == 5:        break # quit the loop entirely    print(x)真值布尔型在python中也和其他语言一样，除了是大写的：one_is_less_than_two = 1 &lt; 2 # equals Truetrue_equals_false = True == False # equals FalseNone表示一个不存在的值，类似于其他语言的null：x = Noneprint(x==None) # prints True, but is not Pythonicprint(x is None) # prints True, and is PythonicPython在它期望布尔值时允许任何值，下面的值都被认为是假值：  False  None  [](空列表）  {}（空字典）  ””  set()  0  0.0其他任何值都被认为是真值，这在if中测试空字符串或空字典时格外有用s = some_function_that_returns_a_string()if s:    first_char = s[0]else:    first_char = \"\"一种更简单的方法是：first_char = s and s[0]因为and操作会在第一个值为真时返回第二个值，第一个值为假时返回第一个值。下面用了类似的技巧：safe_x = x or 0python还有一个all函数，输入一个列表，当列表所有元素是真时返回真，还有一个any函数，至少有一个元素是真时返回真：all([True, 1, {3}]) # Trueall([True, 1, {}]) # False, {} is falsyany([True, 1, {}]) # True, True is truthyall([]) # True, no falsy elements in the listany([]) # False, no truthy elements in the list排序每个python列表都有一个sort方法，如果不想改变原列表，也可以使用sorted函数，会返回一个新列表：x = [4,1,2,3]y = sorted(x) # is [1,2,3,4], x is unchangedx.sort() # now x is [1,2,3,4]默认情况下，列表排序会从小到大进行，如果想要从大到小排序，可以指定reverse=True参数。除了比较元素本身，还可以用参数key指定函数。# sort the list by absolute value from largest to smallestx = sorted([-4,1,-2,3], key=abs, reverse=True) # is [-4,3,-2,1]# sort the words and counts from highest count to lowestwc = sorted(word_counts.items(),           key=lambda pair: pair[1],           reverse=True)列表生成器列表生成器可以很方便的将列表转换成另一个列表，这是典型的Pythonic方法。even_numbers = [x for x in range(5) if x % 2 == 0] # [0, 2, 4]squares = [x * x for x in range(5)] # [0, 1, 4, 9, 16]even_squares = [x * x for x in even_numbers] # [0, 4, 16]这种用法也能把列表转换成字典或集合：square_dict = { x: x * x for x in range(5)} # {0:0, 1:1, 2:4, 3:9, 4:16}squre_set = ( x * x for x in [1, -1]) # {1}如果不需要使用到列表中的值，就用下划线替代：zeroes = [0 for _ in even_numbers] # has the same length as even_numbers列表生成器还能使用多个for：pairs = [(x, y)        for x in range(10)        for y in range(10)]后面的for可以应用前面的for结果：increasing_pairs = [(x, y) # only pairs with x &lt; y                   for x in range(10) # range(lo, hi) equals                   for y in range(x + 1, 10)] # [lo, lo + 1, ..., hi - 1]生成器和迭代器列表有一个问题就是容易变得很大，如果每次只需要使用很少的元素，计算整个列表就会很低效，还可能耗尽内存。生成器是一种可以迭代（常常用for），但值只有在需要使用时才计算。def lazy_range(n):    \"\"\"a lazy version of range\"\"\"    i = 0    while i &lt; n:        yield i        i += 1下面的循环就是依次使用yield里的值直到结束：for i in lazy_range(10):    # do_something_with(i)    print(i)在python3中，range本身就是个生成器，这意味着生成器可以创建无限的序列：def natural_numbers():    \"\"\"returns 1, 2, 3, ...\"\"\"    n = 1    while True:        yield n        n += 1当然在实际应用中需要和break配合使用。生成器的一个缺点就是只能迭代一次，如果需要迭代多次，那就需要新建生成器或者使用列表。另一种创建生成器的方法是使用小括号的列表生成器：lazy_evens_below_20 = (i for i in lazy_range(20) if i % 2 == 0)前面提到dict有一个items()方法可以返回键值对。更常用的我们使用它的iteritems()方法，这就是一个生成器方法。随机数使用random模块，可以很方便的生成随机数。import randomfour_uniform_randoms = [random.random() for _ in range(4)]# [0.8444218515250481, # random.random() produces numbers#  0.7579544029403025, # uniformly between 0 and 1#  0.420571580830845, # it's the random function we'll use#  0.25891675029296335] # most oftenrandom模块实际上产生的是根据内部状态产生伪随机数，如果想要得到可重复结果，可以使用random.seed：random.seed(10) # set the seed to 10print(random.random()) # 0.57140259469random.seed(10) # reset the seed to 10print(random.random()) # 0.57140259469 again有时也会用到random.randrange，可以传1或2个参数，返回一个从range()中随机抽取的值：random.randrange(10) # choose randomly from range(10) = [0, 1, ..., 9]random.randrange(3, 6) # choose randomly from range(3, 6) = [3, 4, 5]另外还有一些方法也很有用，random.shuffle将列表元素随机排列：up_to_ten = list(range(10))random.shuffle(up_to_ten)print(up_to_ten)# [2, 5, 1, 9, 7, 3, 8, 6, 4, 0]想要随机从列表中抽取一个元素，可以使用random.choice：my_best_friend = random.choice([\"Alice\", \"Bob\", \"Charlie\"])如果想要随机抽取一组不重复样本，使用random.samplelottery_numbers = range(60)winning_numbers = random.sample(lottery_numbers, 6)如果想要抽取重复样本，还是使用random.choice：four_with_replacement = [random.choice(range(10)) for _ in range(4)]正则表达式正则表达式在搜索文本时很有用，但其相当的复杂，这里只简单的列举几例：import reprint(all([ # all of these are true, because        not re.match(\"a\", \"cat\"), # * 'cat' doesn't start with 'a'        re.search(\"a\", \"cat\"), # * 'cat' has an 'a' in it        not re.search(\"c\", \"dog\"), # * 'dog' doesn't have a 'c' in it        3 == len(re.split(\"[ab]\", \"carbs\")), # * split on a or b to ['c', 'r', 's']        \"R-D-\" == re.sub(\"[0-9]\", \"-\", \"R2D2\") # * replace digits with dashes    ])) # print True面向对象编程和其他语言一样，python允许你创建类来封装数据和函数。类的使用可以让我们的代码变得简洁。解释类最好的方法还是亲自构造一个。假设现在我们没有内置的集合，我们来自己构造一个集合类。我们的集合类需要有些什么成员函数？我们需要去添加元素，删除元素，验证元素是否存在，因此类构造如下：# by convention, we give classes PascalCase namesclass Set:    # thest are the member functions    # every one takes a first parameter \"self\" (another convention)    # that refers to the particular Set object being used    def __init__(self, values=None):        \"\"\"This is the constructor.        It gets called when you create a new Set.        You would use it like        s1 = Set() # empty set        s2 = Set([1,2,3,4]) # initialize with values\"\"\"        self.dict = {} # each instance if Set has its own dict property        \t\t\t\t\t# which is what we'll use to track memberships        if values is not None:            for value in values:                self.add(value)    def __repr__(self):        \"\"\"this is the string representation of a Set object        if you type is at the Python prompt or pass it to str()\"\"\"        return \"Set: \" + str(self.dict.keys())    # we'll represent membership by being a key in self.dict with    # value True    def add(self, value):        self.dict[value] = True    # value is in the Set if it's a key in the dictionary    def contains(self, value):        return value in self.dict    def remove(self, value):        del self.dict[value]构建完类后，我们可以像内置类那样进行调用：s = Set([1,2,3])s.add(4)print(s.contains(4)) # Trues.remove(3)print(s.contains(3)) # False函数工具有时候我们想要部分应用函数来创建一个新函数：def exp(base, power):    return base ** power现在想创建一个two_to_the函数，输入power，输出exp(2, power)。用下面这种方法可行，但看起来怪怪的：def two_to_the(power):    return exp(2, power)另一种方法是使用functools.partialfrom functools import partialtwo_to_the = partial(exp, 2) # is now a function of one variableprint(two_to_the(3)) # 8也可以通过指定参数名来填充后一个参数：square_of = partial(exp, power=2)square_of(3) # 9我们偶尔也会使用到map,reduce和filter来提供与列表生成器类似的功能。def double(x):    return 2 * xxs = [1, 2, 3, 4]twice_xs = [double(x) for x in xs] # [2, 4, 6, 8]twice_xs = map(double, xs) # same as abovelist_doubler = partial(map, double) # *function* that doubles a listtwice_xs = list_doubler(xs) # again [2, 4, 6, 8]map也能使用多列表来来传递多参：def multiply(x, y): return x * yproducts = map(multiply, [1, 2], [4, 5]) # [1 * 4, 2 * 5] = [4, 10]filter提供了列表生成器中类似if的功能def is_even(x):    \"\"\"True if x is even, False if x is odd\"\"\"    return x % 2 == 0x_evens = [x for x in xs if is_even(x)] # [2, 4]x_evens = filter(is_even, xs) # same as abovelist_evener = partial(filter, is_even) # *function* that filters a listx_evens = list_evener(xs) # again [2, 4]在python3中，reduce已经不是内置函数了，需要从functools中导入，更推荐用列表生成器来处理：from functools import reducex_product = reduce(multiply, xs)list_product = partial(reduce, multiply)x_product = list_product(xs)此外，在python3中，这三个函数都产生生成器而不是之前的列表了。遍历很多时候，经常需要同时遍历列表中的元素及其序号：# not Pythonicfor i in range(len(documents)):    document = documents[i]    do_something(i, document)# also not Pythonici = 0for document in documents:    do_something(i, document)    i += 1Pythonic式的解决办法是是使用`enumerate`:# Pythonicfor i, document in enumerate(documents):    do_something(i, document)类似的，如果我们仅仅想使用序号：for i in range(len(documents)): do_something(i) # not Pythonicfor i, _ in enumerate(documents): do_something(i) # Pythonic打包与解压我们常常需要把两个列表打包起来，zip提供了将多个列表转换成一个含元组的列表的功能：list1 = ['a', 'b', 'c']list2 = [1, 2, 3]zip(list1, list2) # is [('a', 1), ('b', 2), ('c', 3)]如果列表的长度不一致，那就在最短列表处停止。还可以解压回来，代码看起来比较奇怪：pairs = [('a', 1), ('b', 2), ('c', 3)]letters, numbers = zip(*pairs)星号实现了参数解压的功能，把每个列表元素作为zip的参数传入，其相当于下面这个调用：zip(('a', 1), ('b', 2), ('c', 3))最终返回[('a','b','c'),('1','2','3')]这种技巧可以应用在任何函数上：def add(a, b): return a + badd(1,2) # returns 3add([1,2]) # TypeError!add(*[1,2]) # returns 3有没有好奇怪的感觉~~无名参数和关键字参数首先来创建一个高阶函数：def doubler(f):    def g(x):        return 2 * f(x)    return g可以调用如下：def f1(x):    return x + 1g = doubler(f1)print(g(3)) # 8 (==(3+1)*2)print(g(-1)) # 0 (==(-1+1)*2)但假如f不止一个参数时，传入g时就会报错：def f2(x, y):    return x + yg = doubler(f2)print(g(1,2)) # TypeError: g() takes exactly 1 argument (2 given)我们需要一种方法来传递任意参数给函数，我们还是用上了前面的参数解压的技巧：def magic(*args, **kwargs):    print(\"unnamed args:\", args)    print(\"keyword args:\", kwargs)magic(1, 2, key=\"word\", key2=\"word2\")# prints# unnamed args: (1, 2)# keyword args: {'key': 'word', 'key2': 'word2'}当我们这样定义时，args代表的是无名参数构成的元组，kwargs代表的是关键字参数构造的字典。另一方面，如果用列表或元组以及字典来传参，函数也可以构造如下：def other_way_magic(x, y, z):    return x + y + zx_y_list = [1, 2]z_dict = {\"z\": 3}other_way_magic(*x_y_list, **z_dict) # 6这种技巧我们只在构造高阶函数时使用到，下面是正确的g函数：def doubler_correct(f):    \"\"\"works no matter what kind of inputs f expects\"\"\"    def g(*args, **kwargs):        \"\"\"whatever arguments g is supplied, pass them\"\"\"        return 2 * f(*args, **kwargs)    return gg = doubler_correct(f2)print(g(1, 2)) # 6","categories": ["笔记"],
        "tags": ["编程语言","语法","Python"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/crash-python/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "核函数构造习题",
        "excerpt":"相加是核函数，两个半正定矩阵相加仍然是半正定。相减不是核函数，令，则：正系数是核函数负系数不是核函数相乘是核函数，由于是核函数：因此可以推导得到：函数相乘是核函数。上一种情况的特殊化，令。映射核函数是核函数，仍然保持半正定。多项式是核函数，通过上面的证明，相加，系数，幂，截距运算都保持核函数性质。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/construct-kernel-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "感知机核函数化习题",
        "excerpt":"高维系数向量使用高维映射后，更新的方法如下：初始化，可被看做是的线性组合，即，因此可以用线性组合的系数表示。初始的即是系数的空列表。预测新输入因此只需要在每次迭代时计算。而同样可以用上面的方法更新。更新新训练集因为这里是感知机，因此除非样本错误分类，一般是0，否则就是。或者是。因此可以用可以表示向量，即，即只有分类错误的样本才会增添系数。对于新加的样本同样如此。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/kernelize-perceptron-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "用python爬链家房价",
        "excerpt":"之前曾经突发奇想的想做一个房价预测，于是花了点时间去学习python爬虫。结果数据爬下来之后发现房价预测是个时间序列相关的问题，单靠现在一点爬下来的数据显然是行不通的，最后房价预测的问题不了了之了，倒是掌握了简单的爬虫方法。说是爬虫，其实只是学了BeautifulSoup这个库，就能够爬下来网页了。总结起来爬网页最重要的就是分析其结构，然后层层深入到最内层再做一个数据的提取。详细的教程懒得总结了，比较简单，我就是看了《Web Scraping With Python》一二两章，同时参考BeautifulSoup的官方文档，基本就完成了链家上海的二手房数据爬取。下面贴一下我的代码，也没有做多线程，最后大概两个小时跑出来的。import csvfrom urllib.request import urlopenfrom bs4 import BeautifulSoupfile = \"shlj.csv\"url = \"http://sh.lianjia.com/ershoufang/d\"with open(file,'w',newline='') as csvfile:    writer = csv.writer(csvfile)    def house_scrap(house, writer):        title = house.find(\"div\",{\"class\":\"info-panel\"}).a.string        place = house.find(\"div\",{\"class\":\"where\"}).findAll(\"span\")        neighbourhood = place[0].string        layout = place[1].string.strip()        square = place[3].string.strip()        info = [title,neighbourhood,layout,square]        zones = house.find(\"div\",{\"class\":\"con\"}).findAll(\"a\")        for zone in zones:            info.append(zone.string)        details = house.find(\"div\",{\"class\":\"con\"}).findAll(\"span\")        for detail in details:            info.append(detail.next_sibling.string.strip())        price = house.find(\"div\",{\"class\":\"price\"}).span.string        per_price = house.find(\"div\",{\"class\":\"price-pre\"}).string        info.append(price)        info.append(per_price)        writer.writerow(info)    def page_scrap(url,writer):        html = urlopen(url)        bsObj = BeautifulSoup(html)        infos = bsObj.find(\"div\",{\"class\":\"list-wrap\"})        for house in infos.findAll(\"li\"):            house_scrap(house,writer)    for i in range(4000):        page_scrap(url+str(i+1),writer)","categories": ["实践"],
        "tags": ["编程语言","爬虫","Python"],
        "url": "http://localhost:4000/%E5%AE%9E%E8%B7%B5/lianjia-scraping/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "朴素贝叶斯与SVM习题",
        "excerpt":"朴素贝叶斯习题这一篇我得好好记载一下，差不多花了我一整个周日，实际投入时间估计超过八小时，最后还是参考原始的octave代码才写出我的python代码。但不得不说这一题让我也有很大的收获。python文件处理，sparse矩阵利用，贝叶斯公式的本质理解，朴素贝叶斯算法的深入理解，甚至octave语法的复习，都收获到不少。虽然最后自己也有些着急，但最终还是斩获了这道题目。本题的主要难点在于需要真正的去理解朴素贝叶斯算法。讲义中的公式是不计单词次数的，也就是无论出现多少次都按一次计。但本题提供的材料却是考虑了次数。此外，讲义中提供的拉普拉斯平滑公式也有谬误，分母加的是token个数而不是简单的2。此外，需要使用log来解决累乘后概率变小的问题。最后，要预测分类，还需要深入的理解贝叶斯公式。之前我一直陷入一个困惑：如果在垃圾邮件中某个关键词出现的概率是0.9，直观来讲在测试集出现了3次，这个测试集是垃圾邮件的概率应该增大，但按公式来看却减小了。实际上的确是减小了，因为多出现一次后虽然概率有0.9是垃圾邮件，但还有0.1是正常邮件。这0.1体现了称为正常邮件的机会。所以概率这东西真的很神奇。再多谈几句先验概率和后验概率。先验概率就是一个经验概率，独立于测试集存在。经验+现状=结论。展示一下我的代码，虽然简短，但是满满的心血啊！！！import numpy as npfrom scipy.sparse import lil_matrixdef getxy(filename):    f = open(filename)    headerline = f.readline().rstrip() # remove trailing character \\n    row, col = [int(x) for x in f.readline().split()] # convert string to list    tokenlist = f.readline().rstrip()    matrix = lil_matrix((row,col)) # Row-based linked list sparse matrix    category = lil_matrix((row,1))  # To construct a matrix efficiently    for m in range(row):        line = np.array([int(x) for x in f.readline().rstrip().split()])        matrix[m, np.cumsum(line[1:-1:2])] = line[2:-1:2] # the cumulative sum of the elements        category[m] = line[0]    f.close() # remember close the file after finish using it    x = matrix.tocsc() # convert lil_matrix to csc_matrix, for the following dot operation    y = category.toarray().ravel() # convert lil_matrix to dense matrix    return x,y,row,colxt,yt,rowt,colt = getxy('ps2/MATRIX.TRAIN')psi1 = (yt * xt + 1) / (sum((yt) * xt) + colt) # * operation represent dot between 1 -d array with sparse matrixpsi0 = ((1-yt) * xt + 1) / (sum((1-yt) * xt) + colt) # use Laplace smoothingy1 = sum(yt) / rowty0 = 1 - y1xs,ys,rows,cols = getxy('ps2/MATRIX.TEST')yp1 = xs * np.log(psi1) + np.log(y1) # use log convertyp0 = xs * np.log(psi0) + np.log(y0)yp = yp1 - yp0yp[yp &gt; 0] = 1yp[yp &lt;= 0] = 0err = yp - ysprint(len(err[err != 0])/rows)最大概率的五个关键词z = np.log(psi1) - np.log(psi0)temp = np.argpartition(-z,5)result_args = temp[:5]import pandas as pdtokens = pd.read_table('ps2/TOKENS_LIST',header=None, sep = ' ').iloc[:,1].valuestokens[result_args]不同训练样本的测试误差def geterror(trainname, testname):    xt,yt,rowt,colt = getxy(trainname)    psi1 = (yt * xt + 1) / (sum((yt)*xt) + colt) # * operation represent dot between 1 -d array with sparse matrix    psi0 = ((1-yt) * xt + 1) / (sum((1-yt)*xt) + colt) # use Laplace smoothing    y1 = sum(yt) / rowt    y0 = 1 - y1    xs,ys,rows,cols = getxy(testname)    yp1 = xs * np.log(psi1) + np.log(y1) # use log convert    yp0 = xs * np.log(psi0) + np.log(y0)    yp = yp1 - yp0    yp[yp &gt; 0] = 1    yp[yp &lt;= 0] = 0    err = yp - ys    return len(err[err != 0])/rowssamples = [50,100,200,400,800,1400]files = ['PS2/MATRIX.TRAIN.'+ str(x) for x in samples]errors = [geterror(x,'PS2/MATRIX.TEST') for x in files]% matplotlib inlineimport matplotlib.pyplot as pltplt.scatter(samples,errors,color = 'red')plt.hold = Trueplt.plot(samples, np.poly1d(np.polyfit(samples, errors,4))(samples))plt.xlabel('samples')plt.xlim(0,1500)plt.ylabel('errors')使用SVM分类from sklearn import svmdef svmerror(trainname,testname):    xt,yt,rowt,colt = getxy(trainname)    lin_svm = svm.LinearSVC()    lin_svm.fit(xt.toarray(),yt)    xs,ys,rows,cols = getxy(testname)    yp = lin_svm.predict(xs.toarray())    err = yp - ys    return len(err[err != 0])/rowssamples = [50,100,200,400,800,1400]files = ['PS2/MATRIX.TRAIN.'+ str(x) for x in samples]svm_errors = [svmerror(x,'PS2/MATRIX.TEST') for x in files]% matplotlib inlineimport matplotlib.pyplot as pltplt.scatter(samples,svm_errors,color = 'red')plt.hold = Trueplt.plot(samples, np.poly1d(np.polyfit(samples, svm_errors,4))(samples))plt.xlabel('samples')plt.xlim(0,1500)plt.ylabel('errors')朴素贝叶斯和SVM比较朴素贝叶斯能用更少的数据快速学习，但也有较高的渐进误差。相反，SVM在小样本时有较大误差，但能快速的逼近。一般而言，生成算法比判别算法需要更少的样本，但有更高的渐进误差。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/naive-bayes-svm-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Git速成",
        "excerpt":"Git简介Git是一种分布式版本控制系统，由开发出Linux的大神Linus撰写。SVN是目前使用最多的集中式版本库控制系统。安装Git在Ubuntu下可以用下面的命令安装：sudo apt-get install git在Mac下则使用Homebrew：brew install git安装完成后设置一下姓名，邮箱和默认编辑器：git config --global user.name \"Miachel Gu\"git config --global user.email \"anyinlover@gmail.com\"git config --global core.editor vim--global是一个全局参数，也可以对每个Git仓库设置不同的配置。创建版本库创建在某个目录下使用下面的命令，将其初始化成一个Git仓库：git init添加文件到暂存区新添或者修改一个文件后，使用git add将其添加到暂存区：git add filename从暂存区添加到版本库使用命令git commit将暂存区文件提交到仓库, -m后是提交的备注：git commit -m \"add a file\"add和commit分成了两步，可以多次add，一次commit。版本管理git status查看仓库当前的状态：git statusgit diff比较修改过的文件：git diff filename版本回退git log可以用来查看版本记录，其中一大串数字显示的是SHA1计算出来的commit id。用下面的命令可以回退到上一版本，HEAD表示当前版本，HEAD^表示上一版本。依次类推，HEAD^^表示上上版本, HEAD~100表示往上100个版本：git reset --hard HEAD^如果又反悔回退了，只要知道commit_id，仍然可以重新回退到新版本git reset --hard commit_idcommit_id可以只写前面几位，唯一匹配即可。如果关闭窗口后找不到新版本的commit_id了，那就需要使用下面的命令来查看命令历史：git reflog工作区和缓存区Git最重要的概念就是三分天下：工作区-缓存区-版本库。add操作是将工作区的文件加到缓存区中，commit操作是将缓存区文件加到版本库。管理修改Git管理的是修改而非文件。下面的命令可以比较版本库中和工作区中文件的差异：git diff HEAD -- filename撤销修改如果只是修改了工作区的文件，用下面的命令可以撤销到上一次commit或add提交后的状态：git checkout -- filename如果修改已经提交到暂存区了，那就需要使用下面的命令丢弃暂存区修改：git reset HEAD filename记得丢弃暂存区修改后还要丢弃工作区修改。删除文件使用git rm删除文件，后面还需要git commit提交修改：git rm filename假如误删等同于丢弃暂存区修改，想要还原需要两步走：git reset HEAD filenamegit checkout -- filename远程仓库使用SSH方式连接github，需要配置SSH Key。假如主目录下无隐藏文件夹.ssh，就创建一个ssh-keygen -t rsa -C \"anyinlover@gmail.com\"。在.ssh文件下有id_rsa和id_rsa.pub两个文件，将id_rsa.pub内容复制到GitHub SSH Keys，注意不要有多余的空格或换行符。添加远程库在github上Create a new repo，命名为learngit，在本地仓库已存在的情况下，将本地库与远程库相关联：git remote add origin git@github.com:anyinlover/learngit  执行错误提醒： fatal: remote origin already exists.解决办法：git remote rm origin远程库默认名字是origin，不必修改。推送本地库内容到远程库：git push -u origin master参数-u用以将本地master分支与远程master分支关联，以后推送只需要:git push origin master  ssh警告第一次 push 或 clone时出现，用以显示第一次验证github服务器上的SSH key，输入yes即可。克隆远程库对于新项目而言，最好先在在gihub上创建新仓库，然后克隆到本地：git clone git@github.com:guguoshenqi/gitskill.gitGit其实还能支持其他协议，比如https，但https速度慢，且每次推送需要输入口令，只有在只开放http端口的公司内网环境下使用。分支管理分支提供了平行世界的功能，使多人协作更加的方便。创建与合并分支在版本回退中，每次提交Git都会串成时间线也就是分支。在Git中，默认的那个分支称为主分支，即master分支。在前面的单分支情况下，HEAD严格来说是指向master的，而master才是指向提交的，所以HEAD指向的就是当前分支。当新建分支dev时，指向与master相同的提交，并把HEAD指向dev，表示当前分支在dev上。现在对工作区的修改和提交发生在了dev分支上，提交一次后会变成下面这样：如果dev分支的工作完成了，需要将其合并到master上，只需要让master指向dev对应的提交，合并就完成了：这个时候删除dev分支也没有关系（就是删除一个指针），删完后就变成：首先创建并切换到新分支dev上：git checkout -b dev上面的命令相当于下面两步：git branch devgit checkout devgit branch命令可以查看所有分支，带星号的是当前分支。如果想切换分支，使用下面的命令：git chekcout master如果想把dev分支的内容合并到master分支上,Fast-forward是一种快速合并的模式，也就是前面提到的移动指针。有时候可能会不适用这种快速合并的方式。git merge dev合并完成后就可以放心的删除dev分支了：git branch -d dev解决冲突当两个分支都有新的提交时，会发生合并冲突，需要手工修改后重新提交。可以用git log --graph查看分支合并图:git log --graph --pretty=oneline --abbrev-commit分支管理策略Git默认会使用Fast forward模式，这种模式在删除分支后，会丢掉分支信息。如果禁用Fast forward模式合并，会产生一个新的commit，从而可以保存被删除分支信息，使用--no-ff参数：git merge --no-ff -m \"merge with no-ff\" dev实际开发的分支原则  master分支非常稳定，只用来发布新版本  在dev分支上干活，到版本发布时才合并到master  多人协作时每个人在自己分支上干活，时不时合并到dev分支。类似于下图的团队合作：Bug分支如果要修复一个紧急Bug，而现有分支上的工作区又不干净，可以先用下面的命令保存工作现场：git stash在完成创建Bug分支并合并到现有分支时，可以再恢复工作现场。用下面的命令可以查看保存stash列表：git stash list有两种方法可以恢复工作现场git stash apply后不会删除stash列表，需要再用git stash drop来删除。git stach pop在恢复的同时也会删除stash列表。在多次stash的情况下，可以先查看stash列表，然后再恢复指定的stash：git stash apply stash@{0}Feature分支开发一个新feature，最好新建分支。如果要强行删除未合并分支：git branch -D feature-vulcan多人协作当从远程仓库克隆时，Git自动会把本地master分支和远程master分支对应，远程仓库默认名称是origin。要查看远程库的信息，使用git remote，git remote -v 显示更详细的信息。如果要把本地master分支推送到远程：git push origin master如果要推送其他分支，如dev，那就用：git push origin dev注意不是全部分支需要远程推送：  master主分支，dev开发分支需要推送  bug分支一般用于本地修复，不需推送  feature分支是否推送取决于是否合作开发从远程库clone时，默认只有本地master分支，如果要创建远程origin/dev分支到本地：git checkout -b dev origin/dev完成开发后就可以push到远程库。但如果想用git pull抓取远程库，还要指定本地dev分支与远程origin/dev分支的连接：git branch --set-upstream dev origin/dev多人协作的工作模式：  首先，尝试用git push origin branch-name 推送自己的修改；  如果推送失败，是由于远程分支比你的本地更新， 需要先git pull试图合并。  如果合并有冲突，则解决冲突，并在本地提交  没有冲突后再次推送。          如果git pull提示”no tracking information”，说明本地分支和远程分支无关联，参考上面的指令。      标签管理在发布版本时，打一个标签，可以唯一确定打标签时候的版本。标签是版本库的一个快照，实质是一个不能移动的指向commit的指针。创建标签首先切换到要打标签的分支上，创建新标签，默认打在最新提交的commit上：git tag v1.0git tag查看所有标签如果是要为历史提交打标签，需要找到对应的commit_id：git tag v0.9 commit_id如果要查看标签，用git tag找到标签名然后使用下面的命令：git show &lt;tagname&gt;创建标签时还能带上说明文字：git tag -a v0.1 -m \"version 0.1 released\" commit_id用-s则能用私钥签名标签，签名采用PGP签名。需要安装gpg。git tag -s v0.2 -m \"signed version 0.2 released\" commit_id操作标签标签打错是可以删除的：git tag -d v0.1如果要把标签推送到远程：git push origin v1.0还可以推送全部标签到远程：git push origin --tags如果要删除远程标签，有些麻烦，需要先在本地删除，然后：git push origin :refs/tags/v0.9使用github  在Github上， 可以任意Fork开源仓库  自己拥有Fork后的仓库的读写权限  可以推送pull request给官方仓库来贡献代码自定义GitGit除了最前面的姓名和邮箱，还有很多可以配置的。忽略特殊文件在git工作区根目录下建一个.gitignore文件，可以指定不想提交的文件。Github官网有不错的示例。忽略文件原则：  忽略自动生成文件、如缩略图;  忽略编译生成的中间文件、可执行文件等。  忽略自己的带敏感信息的配置文件配置别名git config --global alias.st status还有好些有意思的别名参考原文。配置文件存放位置：  每个仓库的配置在.git/config  当前用户(Global)配置在~/.gitconfig搭建git服务器参考原文","categories": ["工具"],
        "tags": ["git","github"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/crash-git/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 06 - Redireaction",
        "excerpt":"                    Redirect standard output to a file                                          Append redirected output to a file                      2&gt; - Redirect standard error to a file  &amp;&gt; - Redirect standard output and error to a same file  cat - Concatenate files  | - Pipelines  sort - Sort the lines  uniq - Report or omit repeated lines  wc - Print line, word, and byte counts  grep - Print lines matching a pattern  head/tail - Print first/last part of files  tee - Read from stdin and output to stdout and filesStandard Input, Output, And ErrorEverything is a fileRedirecting Standard Outputls -l /usr/bin &gt; ls-output.txtCreate a new, empty file&gt; ls-output.txtAppend redirected output to a filels -l /usr/bin &gt;&gt; ls-output.txtRedirecting Standard Errorls -l /bin/usr 2&gt; ls-error.txtRedirecting Standard Output And Standard Error To One Filels -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1Second modern wayls -l /bin/usr &amp;&gt; ls-output.txtAppend the standard output and standard error streams to a single filels -l /bin/usr &amp;&gt;&gt; ls-output.txtDisposing Of Unwanted Outputls -l /bin/usr 2&gt; /dev/nullRedirecting Standard Inputcat - Concatenate Filescat [file...]Display short text filescat ls-output.txtJoin files togethercat movie.mpeg.0* &gt; movie.mpegRead from standard inputcat  Type Ctrl+d to reach end of file(EOF)Create short text filescat &gt; lazy_dog.txtRedirect standard inputcat &lt; lazy_dog.txtPipelinescommand1 | command2ls -l /usr/bin | lessFiltersls /bin /usr/bin | sort | lessuniq - Report Or Omit Repeated LinesOmit repeated linesls /bin /usr/bin | sort | uniq | lessreport repeated linesls /bin /usr/bin | sort | uniq -d | lesswc - Print Line, Word, And Byte Countswc ls-output.txtwc /bin /usr/bin | sort | uniq | wc -lgrep - Print Lines Matching A Patterngrep pattern [file...]ls /bin /usr/bin | sort |uniq |grep zip-i ignore case-v print lines that do not match the patternhead/tail - Print First/Last Part Of Fileshead -n 5 ls-output.txttail -n 5 ls-output.txtls /usr/bin | tail -n 5view files in real-timetail -f /var/log/syslogtee - Read From Stdin And Output To Stdout And Filesls /usr/bin | tee ls.txt | grep zip","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter06-Redireaction/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 07 - Seeing The World As The Shell Sees it",
        "excerpt":"  echo - Display a line of textExpansionecho this is a testecho *Pathname Expansionecho D*echo /usr/*/shareTilde Expansionecho ~echo ~fooArithmetic Expansionecho $((2+2))Arithmetic Operators            Operator      Description                  +      Addition              -      Subtraction              *      Multiplication              /      Division, only supports integer              %      Modulo              **      Exponentiation      Brace Expansionecho Front-{A,B,C}-Backecho Number_{1..5}Brace expansions may be nestedecho a{A{1,2},B{3,4}}bParameter Expansionecho $USERTo see a list of available variablesprintenv | lessCommand Substitutionecho $(ls)file $(ls -d /usr/bin/* | grep zip)QuotingDouble QuotesParameter expansion, arithmetic expansion and command substitution still take place within double quotesecho \"$USER $((2+2)) $(cal)\"Single QuotesSuppress all expansionsEscaping Charactersecho \"The balance for user $USER is: \\$5.00\"mv bad\\&amp;filename good_filenameBackslash Escape Sequences            Escape Sequence      Meaning                  \\a      Bell              \\b      Backspace              \\n      Newline              \\r      Carriage return              \\t      Tab      Add the “-e” option to echo will enable interpretation of escape sequencessleep 10; echo -e \"Time's up\\a\"Also can place them inside $’ ‘sleep 10; echo \"Time's up\" $'\\a'","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter07-See-The-World-As-The-Shell-Sees-It/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 08 - Advanced Keyboard Tricks",
        "excerpt":"  clear - Clear the screen  history - Display the contents of the history listCommand Line EditingCursor MovementCursor Movement Commands            Key      Action                  Ctrl-a      Move cursor to the beginning of the line              Ctrl-e      Move cursor to the end of the line              Ctrl-f      Move cursor forward one character              Ctrl-b      Move cursor backward one character              Alt-f      Move cursor forward one word              Alt-b      Move cursor backward one word              Ctrl-l      Clear the screen      Modifying TextText Editing Commands            Key      Action                  Ctrl-d      Delete the character at the cursor location              Ctrl-t      Transpose(exchange)the character at the cursor location with the one preceding it              Alt-t      Transpose the word at the cursor location with the one preceding it              Alt-l      Convert the characters from the cursor location to the end of the word to lowercase              Alt-u      Convert the characters from the cursor location to the end fo the word to uppercase      Cutting And Pasting (Killing And Yanking) TextCut And Paste Commands            Key      Action                  Ctrl-k      Kill text from the cursor location to the end of line              Ctrl-u      Kill text from the cursor location the the beginning of the line              Alt-d      Kill text from the cursor location to the end of the current word              Alt-Backspace      Kill text from the cursor location to the beginning of the current word              Ctrl-y      Yank text from the kill-ring and insert it at the cursor location        The Meta key -&gt; AltCompletionTabCompletion Commands            Key      Action                  Alt-?      Display list of possible completions, or press the tab key a second time              Alt-*      Insert all possible completions        Programmable CompletionUsing HistoryThe history of commands is kept in home directory in a file called .bash_history.Searching HistoryView the contents of the history listhistory | lessFind a commandhistory | grep /usr/binUse history line!88 Incremental search  Ctrl-r to start and find next one  Ctrl-g or Ctrl-c to quit searching  Enter to execute the command  Ctrl-j to copy the command for editingHistory Commands            Key      Action                  Ctrl-p      Move to the previous history entry              Ctrl-n      Move to the next history entry              Alt-&lt;      Move to the beginning(top) of the history list              Alt-&gt;      Move to the end(bottom) of the history list              Ctrl-r      Reverse incremental search              Alt-p      Reverse search              Alt-n      Forward search              Ctrl-o      Execute the current item in the history list and advance to the next one      History ExpansionHistory Expansion Commands            Sequence      Action                  !!      Repeat the last command              !number      Repeat history list item number              !string      Repeat last history list item starting with string              !?string      Repeat last history list item containing string        Script: to recond an entire shell session and store it in a file","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter08-Advanced-Keyboard-Tricks/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 09 - Permissions",
        "excerpt":"  id - Display user identity  chmod - Change a file’s mode  umask - Set the default file permissions  su - Run a shell as another user  sudo - Execute a command as another user  chown - Change a file’s owner  chgrp - CHange a file’s group ownership  passwd - Change a user’s passwordLinux: not only multitasking system, but also multi-user systemOwners, Group Members, And Everybody ElseFind out information about your identityidUser accounts are defined in the /etc/passwdGroups are defined in the /etc/groupReading, Writing, And Executing-rw-rw-r-- me\tme 0 2008-03-06 14:52 foo.txtFile Types            Attribute      File Type                  -      A regular file              d      A directory              l      A symbolic link. The remaining file attributes are always “rwxrwxrwx” and are dummy values              c      A character special file, refers to a device that handles data as a stream of bytes              b      A block special file, refers to a device that handles data in blocks      Permission Attributes            Attribute      Files      Directories                  r      Allows a file to be opened and read      Allows a directory’s contents to be listed if the execute attribute is also set              w      Allows a file to be written to or truncated, not allow to be renamed or deleted, which is determined by directory attributes      Allows files within a directory to be created, deleted, and renamed if the execute attribute is also set              x      Allows a file to be treated as a program and executed      Allows a directory to be entered      Permission Attribute Examples            File Attributes      Meaning                  -rwx------      A regular file that is readable, writable, and executable by the file’s owner. No one else has any access              -rw-------      A regular file that is readable and writable by the file’s owner. No one else has any access              -rw-r--r--      A regular file that is readable and writable by the file’s owner. Members of the file’s owner group may read the file. The file is world-readable              -rwxr-xr-x      A regular file that is readable, writable, and executable by the file’s owner. The file may be read and executed by everybody else              rw-rw----      A regular file that is readable and writable by the file’s owner and members of the file’s group owner only.              lrwxrwxrwx      A symbolic link. All symbolic links have “dummy” permissions.              drwxrwx---      A directory. The owner and the members of the owner group may enter the directory and, create, rename and remove files within the directory.              drwxr-x---      A directory. The owner may enter the directory and create, rename and delete files within the directory. Members of the owner group may enter the directory but cannot create, delete or rename files.      chmod - Change File ModeFile Modes In binary And Octal            Octal      Binary      File Mode                  0      000      ---              1      001      --x              2      010      -w-              3      011      -wx              4      100      r--              5      101      r-x              6      110      rw-              7      111      rwx      chmod 600 foo.txtA few common ones: 7(rwx), 6(rw-), 5(r-x), 4(r--), and 0(---)chmod Symbolic Notation            Symbol      Meaning                  u      Short for “user” but means the file or directory owner              g      Group owner              o      Short for “others”, but means world              a      Short for “all”. The combination of “u”, “g”, and “o”      chmod Symbolic Notation Examples            Notation      Meaning                  u+x      Add execute permission for the owner              u-x      Remove execute permission from the owner              +x      Add execute permission for the owner, group, and world              o-rw      Remove the read and write permission from anyone besides the owner and group owner              go=rw      Set the group owner and anyone besides the owner to have read and write permission. If eithet the group owner or world previously had execute permissions, they are removed              u+x, go=rx      Add execute permission for the owner and set the permissions for the group and others to read and execute      umask - Set Default PermissionsSee the current valueumaskSet another valueumask 0022  Some Special Permissionssetuid bit (4000): set the effective user ID from that of the real user (the user actually running the program) to that of the program’s owner.setgid bit(2000): set the effective group ID from the real group ID of the real user to that of the file owner.sticky bit(1000): Prevent users from deleting or renaming files unless the user is either the owner of the directory, the owner of the file, or the superuser.chmod u+s program`-&gt;`-rwsr-xr-xchmod g+s dir`-&gt;`drwxrwsr-xchmod +t dir`-&gt;`drwxrwxrwtChanging Identitiessu - Run A Shell With Substitute User And Group IDssu [-[l]] [user]If -l option is included, the resulting shell session is a login shell for the specified user.To start a shell for the superusersu -Return to the previous shellexitExecute a single command, it’s important to enclose the command in quotessu -c 'commad'sudo - Execute A Command As Another Usersudo commandTo see the privileges granted by sudosudo -lchown - Change File Owner And Groupchown [owner][:[group]] file...chown Argument Examples            Argument      Results                  bob      Changes the ownership of the file from its current owner to user bob              bob:users      Changes the ownership of the file from its current owner to user bob and changes the file group owner to group users.              :admins      Changes the group owner to the group admins. The file owner is unchanged              bob:      Change the file owner from the current owner to user bob and changes the group owner to the login group of user bob      chgrp - Change Group OwnershipUsed in older versions of Unix to change group ownership.Changing Your Passwordpasswd [user]","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter09-Permissions/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 10 - Processes",
        "excerpt":"  ps - Report a snapshot of current processes  top - Display tasks  jobs - List active jobs  bg - Place a job in the background  fg - Place a job in the foreground  kill - Send a signal to a process  killall - Kill processes by name  shutdown - shutdown or reboot the systemHow A Process Worksinit: the kernel launch the program when a system starts upPID: process IDViewing ProcessesShow the processes associated with the current terminal sessionpsShow all of the processes regardless of what terminal (if any) they are controlled by.ps xProcess States            State      Meaning                  R      Running. This means that the process is running or ready to run              S      Sleeping. The process is not running; rather, it is waiting for an event, such as keystroke or network packet              D      Uninterruptible Sleep. Process is waiting for I/O such as a disk drive              T      Stopped. Process has been instructed to stop              Z      A defunct or “zombie” process. This is a child process that has terminated, but has not been cleaned up by its parent              &lt;      A high priority process              N      A process with low priority      Show processes belonging to every userps auxBSD style ps Column Headers            Header      Meaning                  USER      User ID. This is the owner of the process              %CPU      CPU usage in percent              %MEM      Memory usage in percent              VSZ      virtual memory size              RSS      Resident Set Size. The amount of physical memory (RAM) the process is using in kilobytes              START      Time when the process started      Viewing Processes Dynamically With topTo see a more dynamic view of the machine’s activitytopA system summary at the top of the display, followed by a table of processes sorted by CPU activity  h display help  q quit topControlling ProcessesA sample programxlogoInterrupting A Processpress Ctrl - cPutting A Process In The Backgroundxlogo &amp;List the jobs that have been launched from our terminaljobs ### Returning A Process To The Foregroundfg %1If we only have one background job, the jobspec is optionalStopping (Pausing) A Processpress Ctrl - zMoving a process from the foreground to the backgroundbg %1Signalskill 28401Sending Signals To Processes With killkill [-signal] PIDTERM is sent by defaultCommon Signals            Number      Name      Meaning                  1      HUP      Hangup. This is a vestige of the good old days when terminals were attached to remote              2      INT      Interrupt. Same as Ctrl-c              9      KILL      Kill. The kernel immediately terminates the process. A last resort when other termination signas fail              15      TERM      Terminate. The default signal sent by the kill command              18      CONT      Continue. This will restore a process after a STOP signal              19      STOP      Stop. This signal causes a process to pause without terminating. Like KILL      kill -1 13456kill -INT 13601Other Common Signals            Number      Name      Meaning                  3      QUIT      Quit              11      SEGV      Segmentation Violation              20      TSTP      Terminal Stop. Same as Ctrl-z              28      WINCH      Window Change      see a complete list of signalskill -lSending Signals To Multiple Processes With killallkillall [-u usr] [-signal] name...More Process Related CommandsOther Process Related Commands            Command      Description                  pstree      Outpus a process list arranged in a tree-like pattern showing the parent/child relationships between processes              vmstat      Outputs a snapshot of system resource usage including, memory, swap and disk I/O              xload      A graphical program that draws a graph showing system load over time              tload      Similar to the xload program, but draws in the terminal      ","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter10-Processes/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "Chapter 11 - The Environment",
        "excerpt":"  printenv - Print part or all of the environment  set - Set shell options  export - Export environment to subsequently executed programs  alias - Create an alias for a command  source - re-read the configurationWhat is Stored In The Environment?Two basic types of data in the environment: environment variables and shell variables.Some programmatic data: aliases and shell functionsExamining The EnvironmentDisplay environment variables:printenv | lessList the value of a specific variable:printenv USERDisplay both the shell and environment variables:set | lessView the contents of a variable:echo $HOMEView the aliases:aliasSome interesting VariablesEnvironment Variables            Variable      Contents                  DISPLAY      The name of your display if you are running a graphical environment              EDITOR      The name of the program to be used for text editing              SHELL      The name of your shell program              HOME      The pathname of your home directory              LANG      Defines the character set and collation order of your language              PAGER      The name of the program to be used for paging output              PATH      A colon-separated list of directories that are searched when you enter the name of a executable program              PS1      Prompt String 1. This difines the contents of your shell prompt              PWD      The current working directory              TERM      The name of your terminal type              TZ      Specifies your timezone              USER      Your username      How Is The Environment Established?Startup Files For Login Shell Sections            File      Contents                  /etc/profile      A global configuration script that applies to all users              ~/.bash_profile      A user’s personal startup file              ~/.bash_login      If ~/.bash_profile is not found, bash attempts to read this script              ~/.profile      If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts to read this file. This is the default in Ubuntu      Startup Files For Non-Login Shell Sessions            File      Contents                  /etc/bash.bashrc      A golbal configuration script that applies to all users              ~/.bashrc      A user’s personal startup file      What’s In A Startup FileTell the shell to make the contents of PATH available.export PATHModifying The EnvironmentWhich Files Should We Modify?.profile: to add directories to your PATH, or define additional environment variables.bashrc: to everthing elseText Editorsnano, vi, emacsUsing A Text EditorCreate a backup copy before edit an important configuration file.cp .bashrc .bashrc.baknano .bashrcActivating Our Changesmake bash re-read the modified .bashrc file:source .bashrc","categories": ["TLCL"],
        "tags": ["Linux"],
        "url": "http://localhost:4000/tlcl/Chapter11-The-Environment/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "训练测试异分布习题",
        "excerpt":"误差表示我们首先用来表示，然后再反过来表示。误差的出现只有两种可能，第一种是原始分布有误差，点没误差。第二种是原始分布无误差，点有误差，因此误差可以被表示成下式：解得等于：最优表示利用下面的三个条件，我们可以进行推导：可以得到：最后一步令，再代回第一个条件，就得到这个式子与同分布相比多了一个分母。意味着分布误差越大，所需的训练样本数越多。讨论越接近0.5，得到相同生成误差边界所需的样本个数就越多。当接近0.5时，训练数据越来越趋于随机，当时就没有有用的信息了。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tt-diff-dis-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "VC维习题",
        "excerpt":"假说集的VC维大小比较第一个结论为真。令，也就是存在一组d个点可以被分割。即对于d个点的任意标签，都存在某一个假说来实现分割。由于包含了所有的假说，因此也能分割这组点集。因此有。假说集的VC维数量第二个结论为真。如果能证明成立，后面就可以通过递归来实现。因此。首先证明如果，那么有成立。令，是一组可被分割的d个点的点集。现在任意选取某一个，必然存在，两者除了x，对其他点的分割是一致的。这意味着对于点集，可以用假说集 分割。因此有，同时， 根据上一节的结论有，因此，即。并集的VC维第三个结论为假。给出一个反例。令，因此有，但对于 而言，，因此。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/vc-ps/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "高级数据过滤",
        "excerpt":"本讲主要学习通过组合WHERE条件来创建复杂的搜索条件。同时还会用到NOT和IN操作符。WHERE条件组合通过AND和OR这两个逻辑操作符，我们可以把多个WHERE条件组合起来。使用AND操作符SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = 'DLL01' AND prod_price &lt;= 4;使用OR操作符SELECT prod_name, prod_priceFROM ProductsWHERE vend_id='DLL01' OR vend_id = 'BRS01';理解操作符顺序就像大部分其他语言一样，SQL中AND操作符的优先级高于OR操作符，要指定OR在前面，需要使用括号：SELECT prod_name, prod_priceFROM ProductsWHERE vend_id='DLL01' OR vend_id = 'BRS01'\t\tAND prod_price &gt;= 10;SELECT prod_name, prod_priceFROM ProductsWHERE (vend_id='DLL01' OR vend_id='BRS01')\t\tAND prod_price &gt;= 10;使用IN操作符SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN('DLL01','BRS01')ORDER BY prod_name;使用NOT操作符SELECT prod_nameFROM ProductsWHERE NOT vend_id = 'DLL01'ORDER BY prod_name;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/advanced-data-filtering/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "过滤数据",
        "excerpt":"这一讲主要学习SELECT语句中的WHERE条件来指定搜索条件。使用WHERE条件SELECT prod_name, prod_priceFROM ProductsWHERE prod_price = 3.49;虽然数据可以从应用层面过滤，但强烈建议从数据库层面过滤。注意WHERE条件需要放在ORDER BY条件前面。WHERE条件操作符检查单值SELECT prod_name, prod_priceFROM ProductsWHERE prod_price &lt; 10;SELECT prod_name, prod_priceFROM ProductsWHERE prod_price &lt;= 10;检查不匹配SELECT vend_id, prod_nameFROM ProductsWHERE vend_id &lt;&gt; 'DLL01';SELECT vend_id, prod_nameFROM ProductsWHERE vend_id != 'DLL01';检查值范围SELECT prod_name, prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10;检查空值SELECT cust_nameFROM CustomersWHERE cust_email IS NULL;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/filtering-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "获取数据",
        "excerpt":"本章中主要学习SELECT的用法来从表中获取数据。SELECT语句SQL语句由英语术语构成，这些术语是SQL语言的保留字，被称为关键字，不能拿来用作表名或列名。最简单的SELECT语句由两部分构成，取什么，从哪取。从单列读取SELECT prod_nameFROM Products;一个简单的SELECT语句仅仅是取回了所有的行，数据既不筛选，也不排序。从多列读取SELECT prod_id, prod_name, prod_price FROM Products;读取所有列SELECT * FROM Products;读取不同值的行SELECT distinct vend_id FROM Products;限制返回的数量只想返回头五行：SELECT prod_name FROM Products LIMIT 5;要读取下五行，还可以设置偏移：SELECT prod_name FROM Products LIMIT 5 OFFSET 5;MySQL还支持偏移的简写，前面的是限制数，后面的是偏移量：SELECT prod_name FROM Products LIMIT 5,5;使用评论下面是行内注释的用法：SELECT prod_name  -- this is a commentFROM Products;下面是多行注释的用法：/* SELECT prod_name, vend_idFROM Products;*/SELECT prod_nameFROM Products;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/retrieving-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "排序数据",
        "excerpt":"这一讲主要学习使用SELECT语句中的ORDER BY条件来对获取到的数据进行排序。数据排序SELECT prod_nameFROM ProductsORDER BY prod_name;多列排序SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price, prod_name;通过列位置排序SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY 2, 3;通过列位置排序可以省略列名，但同时也会有误选，更改，不能指定SELECT外列名等缺点。指定排序方向默认的排序方向是从A到Z，如果想要反方向排序，可以使用关键字DESC。SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC;如果要对多列指定排序方向，记得DESC只对前一个列名生效，也就是说，要让多列都降序排列，必须每一列都指定DESC：SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC, prod_name;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/sorting-retrieved-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "了解SQL",
        "excerpt":"数据库基础SQL是一种用来和数据库交互的语言，因此在学习SQL之前必须了解一些数据库概念及数据库技术。数据库数据库是存储结构化数据的容器（通常以文件的形式）。注意不要将数据库与数据库软件混淆，后者通常被称为数据库管理系统（DBMS)。表表是一个结构化的文件用来存储特定类型的数据。每张表都会有一个表名，数据库名加表名通常是独一无二的。模式是一组描述数据库和表的分布及属性的相关信息。列和数据类型表由列构成，列是数据库中单一的域。每个列都会指定允许的数据类型。数据类型也是造成不同数据库之间兼容性问题的主要来源。行数据在表中以行的形式存储，一条记录就是一行。主键主键是区分每一行独特性的列。指定主键可以方便更新或删除特定行。任意列只要满足下面四个条件都可以作为主键：  没有两行有相同的主键值。  每一行都有主键值。  主键值不能被修改或更新。  主键值不会被重用。也允许多列组合成主键。SQLSQL是结构化查询语言(Structured Query Language)的缩写。专门为数据库而设计。具有通用性。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/understanding-sql/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "通配符过滤",
        "excerpt":"这一讲主要学习使用通配符和LIKE操作符来过滤数据。使用LIKE操作符通配符和LIKE操作符一块使用，可以进行模糊搜索。百分号%通配符%通配符可以表示任意数量的任意字符。注意%也能代表0个字符，但它匹配不到NULL值。SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE 'Fish%';SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '%bean bag%';下划线_通配符_通配符只能表示一个字符。SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE '__ inch teddy bear';方括号[]通配符SELECT cust_contactFROM CustomersWHERE cust_contact RLIKE '^[JM]'ORDER BY cust_contact;使用通配符的技巧  不要过度使用  尽量不要在开头使用  注意通配符放置位置","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/using-wildcard-filtering/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "组合查询",
        "excerpt":"本讲主要学习使用UNION操作符来联合多SELECT语句。理解组合查询有两种场景需要使用组合查询。  从不同表中返回相似结构的数据  从单表中执行多次查询，这种情况和使用多WHERE分句的效果是一致的。创建组合查询SQL查询通过UNION操作符组合在一起。使用UNIONUNION简单的把两个SELECT区分开来：SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI')UNIONSELECT cust_name,cust_contact,cust_emailFROM CustomersWHERE cust_name='FUN4All';UNION规则UNION有一些规则需要遵循：  一个UNION必须有两或多个SELECT构成。  每个查询都必须包含相同的列，表达式或统计函数。  列数据类型必须可兼容。包含或省略重复行UNION默认会省略重复行，类似于多WHERE分句。如果要包含重复行，使用UNION ALL:SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI')UNION ALLSELECT cust_name,cust_contact,cust_emailFROM CustomersWHERE cust_name='FUN4All';组合查询结果排序组合查询的排序必须放在最后一个SELECT之后：SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI')UNIONSELECT cust_name,cust_contact,cust_emailFROM CustomersWHERE cust_name='FUN4All'ORDER BY cust_name, cust_contact;组合查询在组合不同表的数据时非常有用，即使列名不同，也可以通过别名来保持一致。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/combining-queries/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "创建高级连接",
        "excerpt":"本讲主要学习其他连接类型，以及如何使用表别名和在连接表中使用统计函数。使用表别名SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id=O.cust_id\tAND OI.order_num=O.order_num    AND prod_id='RGAN01';使用不同类型的连接上一讲的连接被称为内连接或者等连接。下面介绍另外三种连接类型：自连接，自然连接和外连接。自连接下面两个SQL实现相同的功能：SELECT cust_id, cust_name, cust_contactFROM CustomersWHERE cust_name = (SELECT cust_name\t\t\t\t\t\tFROM Customers\t\t\t\t\t\tWHERE cust_contact = 'Jim Jones');SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name=c2.cust_name\tAND c2.cust_contact='Jim Jones';第二个SQL使用了自连接，看似两张表，其实只用了一张表的数据。很多数据库自连接跑的比子查询更高效，因此自连接值得一试。自然连接内连接会返回所有的列，即使数据是重复的。自然连接会把重复的列去除。而实现的方法就是手工指定~SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id=O.cust_id\tAND OI.order_num=O.order_num    AND prod_id='RGAN01';外连接连接中大部分行都会在另一张表中有对应的行。但有时也会发生没有对应行的情况。这时候就需要使用外连接。SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN Orders\tON Customers.cust_id=Orders.cust_id;SELECT Customers.cust_id, Orders.order_numFROM Customers RIGHT OUTER JOIN Orders\tON Customers.cust_id=Orders.cust_id;外连接有两种基本类型，左外连接和右外连接。分别指定哪张表选择所有的行。连接的统计函数SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN Orders\tON Customers.cust_id=Orders.cust_idGROUP BY Customers.cust_id;使用连接和连接条件总结一下使用连接的几个关键点：  注意连接的类型，大部分情况下使用内连接。有时也会用到外连接。  不同数据库管理系统的连接语法略有不同。  要使用正确的连接条件。  一定要提供连接条件。  可以多表连接，甚至采取不同连接方式。但建议做分布测试，方便定位。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/creating-advanced-joins/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "创建操作表",
        "excerpt":"本讲主要学习表的创建，更新和删除的基本操作。创建表一般来说有两种方式可以创建表，DBMS自身的交互工具和SQL语句。基本表创建CREATE TABLE MyProducts(prod_id\tCHAR(10)\tNOT NULL,vend_id\tCHAR(10)\tNOT NULL,prod_name\tCHAR(254)\tNOT NULL,prod_price\tDECIMAL(8,2)\tNOT NULL,prod_desc\tVARCHAR(1000)\tNULL);使用NULL值如果指定了NOT NULL，那么这一列的数据就不能为空。默认值是NULL，可以省略：CREATE TABLE MyVendors(vend_id\tCHAR(10)\tNOT NULL,vend_name\tCHAR(50)\tNOT NULL,vend_address\tCHAR(50),vend_city\tCHAR(50),vend_state\tCHAR(5),vend_zip\tCHAR(10),vend_country\tCHAR(50));指定默认值CREATE TABLE MyOrderItems(order_num\tINTEGER\tNOT NULL,order_item\tINTEGER\tNOT NULL,prod_id\tCHAR(10)\tNOT NULL,quantity\tINTEGER\tNOT NULL\tDEFAULT 1,item_price\tDECIMAL(8,2)\tNOT NULL);更新表ALTER TABLE VendorsADD vend_phone CHAR(20);ALTER TABLE VendorsDROP COLUMN vend_phone;更新表同样是一个危险的操作，完整的步骤如下：  创建一张新表结构的表  使用INSERT SELECT复制数据  验证新表可用  重命名旧表  重命名新表  新建触发器，存储过程，索引和外键删除表DROP TABLE MyVendors;重命名表RENAME TABLE MyOrderItems to YouOrderItems;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/creating-and-manipulating-tables/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "创建计算字段",
        "excerpt":"本讲主要学习什么是计算字段，如何创建，以及如何使用别名。理解计算字段有时候存储在数据库的字段不能很好的对应于应用中，这时候就需要对字段进行加工组合，形成计算字段。串联字段SELECT CONCAT(vend_name, ' (', vend_country, ')')FROM VendorsORDER BY vend_name;如果字段后面有尾缀空格，可以用RTRIM去除：SELECT CONCAT(RTRIM(vend_name), ' (', RTRIM(vend_country), ')')FROM VendorsORDER BY vend_name;使用别名SELECT CONCAT(vend_name, ' (', vend_country, ')')\t\t\tAS vend_titleFROM VendorsORDER BY vend_name;别名也可以使用在别的地方，比如原始列名包含非法字符或者过于冗长或误读。执行数学运算SELECT prod_id, quantity, item_priceFROM OrderItemsWHERE order_num = 20008;SELECT prod_id, \t\tquantity,       \titem_price,        quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num=20008;SELECT还能用来测试函数和计算，这时候可以省略FROM。比如SELECT 3 * 2返回6，SELECT curdate()返回当下的日期和时间。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/creating-calculated-fields/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "分组数据",
        "excerpt":"本讲主要学习数据分组，使用了GROUP BY和HAVING字段。理解数据分组前一讲提到了SQL的统计函数，但那都是对全局数据操作的。如果要统计某个子集的数据，那就需要用到数据分组了。创建分组使用GROUP BY关键字可以创建分组：SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id;对于创建分组有几条重要的规则：  GROUP BY可以包含多列，嵌套分组。  嵌套分组时数据在最后一列统计。  GROUP BY中的列可以是原始列或者有效表达式（不能是统计函数），不能是别名。  除了统计函数，SELECT中的每一列都必须在GROUP BY中。  NULL会被单独分为一组返回。  GROUP BY防止在WHERE后，ORDER BY前。过滤分组对于组还可以过滤，使用HAVING关键字。其与WHERE的区别是过滤行和过滤组的区别，此外，WHERE是在分组前的过滤，HAVING是在分组后的过滤。SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*)&gt;=2;此外，WHERE是在分组前的过滤，HAVING是在分组后的过滤。有可能同时会使用两者：SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsWHERE prod_price&gt;=4GROUP BY vend_idHAVING COUNT(*)&gt;=2;分组和排序注意分组和排序是两回事。下面的例子可以说明：SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*)&gt;=3SELECT order_num, COUNT(*) AS itemsFROM OrderItemsGROUP BY order_numHAVING COUNT(*)&gt;=3ORDER BY items, order_num;SELECT分句次序是时候总结一下SELECT分句次序了。            分句      作用      必要性                  SELECT      返回列或表达式      必要              FROM      指定表      从表中取数据时必要              WHERE      行过滤      不必要              GROUP BY      分组      分组统计必要              HAVING      组过滤      不必要              ORDER BY      结果过滤      不必要      ","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/grouping-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "插入数据",
        "excerpt":"本讲主要学习使用INSERT语句插入数据。理解数据插入SELECT毫无疑问是最常用的SQL语句，但还有其他三个常用SQL语句，第一个就是INSERT。INSERT用来在数据库表中插入行，有三种用途：  插入完整单行  插入部分单行  插入查询结果插入完整单行INSERT INTO CustomersVALUES('1000000006',\t\t\t'Toy Land',            '123 Any Street',            'New York',            'NY',            '11111',            'USA',            NULL,            NULL);上面这种插入方式严重依赖于列次序，是很不安全的操作，建议用下面的方式插入：INSERT INTO Customers(cust_id,\t\t\t\t\tcust_name,\t\t\t\t\tcust_address,\t\t\t\t\tcust_city,\t\t\t\t\tcust_state,\t\t\t\t\tcust_zip,\t\t\t\t\tcust_country,\t\t\t\t\tcust_contact,\t\t\t\t\tcust_email)VALUES('1000000007',\t\t\t'Toy Land',            '123 Any Street',            'New York',            'NY',            '11111',            'USA',            NULL,\t\t\tNULL);插入部分单行如果数据库允许某一列的值为空，或有指定的默认值，可以在插入时省略该行：INSERT INTO Customers(cust_id,\t\t\t\t\tcust_name,                    cust_address,                    cust_city,                    cust_state,                    cust_zip,                    cust_country)VALUES('1000000008',\t\t\t'Toy Land',            '123 Any Street',            'New York',            'NY',            '11111',            'USA');插入获取到的数据INSERT还可以用来插入SELECT获取到的数据，被称为INSERT SELECT。INSERT INTO Customers(cust_id,\t\t\t\t\tcust_name,                    cust_address,                    cust_city,                    cust_state,                    cust_zip,                    cust_country)\t\t\tSELECT cust_id,\t\t\t\t\tcust_name,                    cust_address,                    cust_city,                    cust_state,                    cust_zip,                    cust_country\t\t\tFROM CustNew;INSERT通常只能插入单行数据，但INSERT SELECT是个例外，其可以一次性插入多行数据。复制表CREATE TABLE CustCopy ASSELECT * FROM Customers;复制表操作在测试新的SQL语句时很有用。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/inserting-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "连接表",
        "excerpt":"本讲主要学习连接表的作用和创建。理解连接连接表是SQL语句的一个重要特性，也是SELECT中主要的操作。理解连接和连接语法是学习SQL中非常重要的一部分。在理解连接之前，有必要先了解关系表和关系型数据库的设计。理解关系表关系表被设计成用来将信息分割成多张表，每张条对应一种数据类型。为何使用连接将数据分散在不同表里可以更高效的存储，更简单的操作，以及更好的扩展。但当要获取的数据分散在不同表里时，就需要使用连接使得SELECT操作可以从多表中获取数据。创建连接SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id=Products.vend_id;WHERE分句的重要性WHERE分句指定了两张表的关系。内连接上述的这种连接也被称为内连接，连接是建立在两表的相同性上的。内连接还可以用一种ON分句来替代WHERE分句，作用是一致的：SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN Products\tON Vendors.vend_id=Products.vend_id;连接多表连接表的数量是不受限制的，只需要指定关系即可：SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id=Vendors.vend_id\tAND OrderItems.prod_id=Products.prod_id    AND order_num=20007;回顾上一讲的子查询，我们可以发现用内连接也可以实现它的功能，下面两个SQL语句的功能就是一致的，具体哪个更高效视情况而定，需要测试。SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_id\t\t\t\t  FROM Orders                  WHERE order_num IN (SELECT order_num\t\t\t\t\t\t\t\t\t  FROM OrderItems                                      WHERE prod_id='RGAN01'));                                          SELECT cust_name, cust_contactFROM Customers, Orders, OrderItemsWHERE Customers.cust_id=Orders.cust_id\tAND OrderItems.order_num=Orders.order_num    AND prod_id='RGAN01';","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/joining-tables/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "统计函数",
        "excerpt":"本讲主要学习SQL统计函数来总结整表数据。使用统计函数SQL提供了五种统计函数，用于对数据进行一个总结性的了解。            函数      作用                  AVG()      平均值              COUNT()      行数              MAX()      最高值              MIN()      最低值              SUM()      和值      AVG()函数SELECT AVG(prod_price) AS avg_priceFROM Products;SELECT AVG(prod_price) AS avg_priceFROM ProductsWHERE vend_id = 'DLL01';NULL值会被AVG()忽略不计。COUNT()函数使用COUNT(*)会计算所有的行数，包括NULL值的。SELECT COUNT(*) AS num_custFROM Customers;使用COUNT(column)则会把NULL值排除在外。SELECT COUNT(cust_email) AS num_custFROM Customers;MAX()函数SELECT MAX(prod_price) AS max_priceFROM Products;除了应用在数字数据上，MAX()也可以应用在文本数据上。MIN()函数SELECT MIN(prod_price) AS min_priceFROM Products;和MAX()类似，MIN()也能应用在文本数据上。SUM()函数SELECT SUM(quantity) AS items_orderedFROM OrderItemsWHERE order_num=20005;SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num=20005;独特值统计如果要计算独特值得统计数据，可以使用DISTINCT关键字，但注意只能配合列名使用：SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id='DLL01';联合统计函数SELECT COUNT(*) AS num_items,\t\tMIN(prod_price) AS price_min,      \tMAX(prod_price) AS price_max,        AVG(prod_price) AS price_avgFROM Products;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/summarizing-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "更新和删除数据",
        "excerpt":"本讲主要学习UPDATE和DELETE语句来操作数据。更新数据UPDATE主要有两种用法：  更新特定行  更新所有行UPDATE CustomersSET cust_email='kim@thetoystore.com'WHERE cust_id='1000000005';UPDATE CustomersSET cust_contact='Sam Roberts',\tcust_email='sam@toyland.com'WHERE cust_id='1000000006';UPDATE CustomersSET cust_email=NULLWHERE cust_id='1000000005';删除数据DELETE FROM CustomersWHERE cust_id='1000000008';注意如果要删除的行中存在其他表的外键，那么删除操作是无法完成的。更新删除数据指南下面是一些实用的更新删除数据指南：  永远不要在没有WHERE分句的情况下更新和删除，除非你真的想操作所有行。  确保每张表都有一个主键，尽可能在WHERE分句中使用它。  在用WHERE分句更新删除前，先用SELECT测试查看。  使用数据库的强制参考完整性特性，即上面提到的外键。  考虑DBA强制在更新删除时使用WHERE。","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/updating-and-deleting-data/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "使用数据处理函数",
        "excerpt":"本讲中主要学习什么是函数，数据库支持哪些类型的函数，以及如何使用这些函数。理解函数和其他语言一样，SQL也支持使用函数来处理数据。比如前面提到的RTRIM但SQL函数有一个问题，就是和数据库管理系统强相关。不同的数据库支持的函数差别较大。因此，使用函数来处理数据时，一个好的习惯是加上注释。使用函数大部分SQL实现了下面四种类型的函数：  文本函数，处理文本字符串。  数字函数，数学运算。  时间日期函数。  系统函数。函数除了使用在SELECT部分，也可以使用在SQL语句的其他部分，比如WHERE。文本处理函数SELECT vend_name, UPPER(vend_name) AS vend_name_upcaseFROM VendorsORDER BY vend_name;下面是一些通用的文本处理函数：            函数      作用                  LEFT()      从左取子字符串              LENGTH()      字符串长度              LOWER()      字符串小写              LTRIM()      截除字符串首空格              RIGHT()      从右取字符串              RTRIM()      截除字符串尾空格              SOUNDEX()      返回字符串音值              UPPER()      字符串大写      这里面SOUNDEX()比较特殊，用来查找发音相似的字符串：SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact)=SOUNDEX('Michael Green');日期时间处理函数日期和时间在数据库中以数据库管理系统特有的格式存储，实际使用时需要通过日期时间处理函数来调用，这一部分函数非常重要，但同时也非常不具有普遍性。SELECT order_numFROM OrdersWHERE YEAR(order_date)=2012;具体的日期时间处理函数需要参照不同SQL的产品文档。数字函数数字函数和上面两者相比最不常用，却是最普遍性的。下面列举一些常见的数字处理函数：  ABS()  COS()  EXP()  PI()  SIN()  SQRT()  TAN()","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/using-data-manipulation-functions/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "使用视图",
        "excerpt":"本讲主要学习视图，原理及何时使用。可以看到视图能够简化操作。理解视图视图是虚拟的表，它没有实体的数据，只是包含动态查询的结果。为何使用视图视图有以下几个常见的用法：  重用SQL语句  简化复杂SQL操作  导出部分表  保护数据  更改数据的样式和表达当视图创建之后，它可以执行和表一样的操作。视图的规则和限制  视图的命名也必须是唯一的。  视图的数量没有限制。  创建视图需要有安全权限。  视图可以嵌套。  视图不可被索引，不能有触发器或默认值。创建视图使用CREATE VIEW语句创建视图。使用视图来简化复杂连接CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id=Orders.cust_idAND OrderItems.order_num=Orders.order_num;SELECT cust_name, cust_contactFROM ProductCustomersWHERE prod_id='RGAN01';使用视图更改数据样式Create VIEW VendorLocations ASSELECT CONCAT(vend_name, ' (', vend_country, ')')AS vend_titleFROM Vendors;SELECT * FROM vendorlocations;使用视图过滤不必要的数据CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL;SELECT * FROM CustomerEMailList;使用视图表示计算字段CREATE VIEW OrderItemsExpanded ASSELECT order_num,\t\tprod_id,        quantity,        item_price,        quantity*item_price AS expanded_priceFROM OrderItems;SELECT * FROM OrderItemsExpandedWHERE order_num=20008;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/using-views/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "使用子查询",
        "excerpt":"本讲主要学习子查询及其使用。理解子查询前面的SELECT语句都是简单的查询，SQL还允许在查询中嵌套查询，这就是子查询。使用子查询过滤SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_num\t\t\t\t\tFROM OrderItems\t\t\t\t\tWHERE prod_id = 'RGAN01');                    SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_id\t\t\t\t  FROM Orders                  WHERE order_num IN (SELECT order_num\t\t\t\t\t\t\t\t\t  FROM OrderItems                                      WHERE prod_id='RGAN01'));注意子查询虽然能达成目的，但经常不是最有效的方式。后续会讲到连接表也能达到同样的效果。使用子查询作为计算字段SELECT cust_name, cust_state,\t(SELECT COUNT(*)     FROM Orders     WHERE Orders.cust_id=Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name;","categories": ["笔记"],
        "tags": ["编程语言","SQL"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/working-with-subqueries/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "主成分分析",
        "excerpt":"前一讲因子分析中，将数据投射到k维子空间，它是一个可能性模型，使用EM算法拟合参数。本讲中的主成分分析完成类似的功能，但却简单的多，只需要用到特征向量，不需要借用EM算法。在实现PCA算法之前，需要先对数据进行预处理：  令  将 用代替  计算  将用如果知道两个特征的范围大小一致，后两步可以省略。现在我们就是要找出一个方向，使得投射后的数据仍然有高的方差。即最大化下式：当时，很容易得知u取经验协方差矩阵的特征向量时为最大值。当想得到一维子空间时，u取首要特征向量。更一般化，要投射到k维子空间时，取头k个特征向量：。子空间的特征可以用对应的向量表示：PCA也被称为降维算法。向量被称为k个主成分。PCA算法有很多应用场景。  将数据压缩到二或三维可以用作可视化  在监督学习前使用PCA来降低数据复杂度，避免过拟合。  PCA算法可以用来降噪。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习理论"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/principal-components-analysis/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "独立成分分析",
        "excerpt":"考虑一个鸡尾酒派对，不同位置的n个麦克风记录了n个说话者的声音。我们的目标是区分原始n个说话者的信号。用公式来表达，假设有一些数据通过n各独立源产生，我们观察到的是：这里A是一个未知的方矩阵被称为混合矩阵。重复观察可以得到数据集，目标就是还原源数据。令为分离矩阵，我们的目标变成找到W,因为。令表示W的第i行，则。ICA的任意性如果对源和混合矩阵没有任何先验知识，只是给出，容易看出A是具有一些任意性的。如果P是任意一个的重排列矩阵，这意味这每一行每一列都只包含一个1，那么我们是无法区分W和PW的，因为源数据的排列次序不会影响观察到的x。同样的，对W进行系数的缩放也没有影响。对于非高斯分布的数据源而言，只存在上面两种任意性。如果数据源是高斯分布的，考虑下面的例子。。那么对于观察数据而言，x也是一个高斯分布，平均值为0，方差为。现在令R是任意一个正交矩阵，即，则有，当混合矩阵是时，我们观察到。的分布同样属于高斯分布，平均值为0，方差为。也就是无论混合矩阵是A还是，最终观察到的都是的分布。上述讨论是建立在对称的标准多变量正态分布上的，尽管ICA不能在高斯分布数据中应用，在实际应用于非高斯分布数据中，只要数据足够多，是可以还原成n个独立源的。分布密度和线性转换假设随机变量s的分布密度是，那么x的分布密度可以用下式表示：ICA算法假设每个数据源的分布由分布密度给出，则s的联合分布由下式给出：也可以得到的分布密度：回顾累积分布函数(cdf)的定义，，z的分布密度也可以通过求导得到。因此，要确定s的分布密度，只需要确定cdf，它从0增长到1。根据我们上面的讨论，cdf不能取高斯函数，我们选择S型函数，（假如对源分布有先验知识，这里应该利用先验知识构建cdf）。方矩阵W是模型的参数，给定训练集，对数似然函数是：使用随机梯度上升法则更新W，对于一个训练样本，更新规则是：上面的推导包含了样本独立分布的假设，因此可以直接来最大化。但实际上说话者案例中样本并非完全独立，它们是时间相关的。但假如样本数足够多，ICA算法仍然有效。事实上，当样本具有相关性时，有时候还帮助我们加快拟合，类似于随机排序功能。","categories": ["机器学习"],
        "tags": ["Ng机器学习系列","机器学习理论"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/independent-components-analysis/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "树",
        "excerpt":"背景基于树的方法将特征空间分割成一系列长方形，然后用一个简单的模型（类似于常量）来拟合。树的概念简单，但往往很有效。我们首先来看一种最常见的基于树的回归分类算法CART。CART是一类迭代二叉树，其关键优势在于其可解释性。每次都只分割一个特征。回归树现在我们来讨论如何构造一棵回归树。对于N次观察，我们的数据由p个输入和一个输出构成。即。算法需要自动确定分割的变量和分割点，以及树的模型。首先假设我们分割成M个区域，将每个区域映射成一个常量：如果我们采用最小二乘法，很容易得到最好的就是区域中的平均值：我们使用贪婪算法来找出最优的分割变量j和分割点s，定义如下一对分割面：通过解决下式来找到分割变量j和分割点s：通过不断迭代，可以完成树的构造。一般在达到最小节点数目时停止构造。树的大小是控制模型复杂度的一个重要调优参数。最常使用的策略是构造一个大的树，然后使用代价复杂度对树进行剪枝。我们定义为任意一个可以通过对剪枝得到的子树，令叶节点索引为m，节点m代表着分区，代表叶节点的数目。令：定义代价复杂度公式为：这意味着树的大小和拟合度之间的平衡。越小，树越大，否则相反。当时，结果就是一个满树。对于任一个都有一个特定的最小子树使得最小。我们使用最弱连接剪枝算法：每一次拿走一个中间的节点使得增加最小，直至只留下根节点。可以证明我们要的最小子树必然在这一系列树中。的选择可以通过交叉验证来择取。分类树对于需要输出分类结果的分类树而言，和决策树相比唯一需要改变的就是分割节点和修剪树的算法。对节点m而言，次观测区域，令：作为k类样本在节点m中的比例，我们将节点m分类为。对于不纯度主要有三种衡量方法：误分类率：gini系数：互熵：其中gini系数和互熵是可导的，因此更适合做数值优化。此外和回归树类似，在分割后的两个节点里都需要计算不纯度。此外gini系数和互熵对节点概率的变化更加敏感。因此常常使用gini系数和互熵来生成树。三种方法都可以应用在代价复杂度剪枝上。但最常用的是误分类率。gini系数有另外两种有趣的解释。如果不以主要类的角度去看，对于每一个类k而言都有可能性，因此总的误分类率是。类似的，将每一个类都看做一个伯努利分布，则其方差是，对所有类累加也得到gini系数。其他讨论分类预测如果分类器有q个可能值，那么分成两组时就会有种可能的分法，当q很大时，结果会非常巨大。当结果只是0-1时，那么分类就会很简单。这对计算gini系数或互熵而言同样如此。分组的算法更青睐有更多层数的分类器，分组更多，就更有可能找到一个吻合数据的结构。但同时也可能发生过拟合。损失矩阵在分类问题中，不同类的误分类严重性不一致。我们定义一个的损失矩阵，其中代表将误分类成。在模型中，可以将gini系数修改成。这种方法只使用于多分类。对于二分类而言，选择。在叶节点，我们定义类。预测值缺失仅仅将预测值缺失的样本删除可能导致样本数不够。有两种更好的方法解决。第一种应用于分类预测中，简单的将缺失值分为一个新的类。第二种是首先使用预测值不缺失的样本构造一个首要分类器，然后再构建一系列的替代分类器，以和首要分类器偏差小为序。这种预测值的替代试图来减少预测值缺失的影响。为什么使用二分法我们也可以每一次分成多个组。但这样有可能造成分组过快，在下一层没有足够多的数据来分了。由于一次分多组相当于多次二分，因此更应该选择二分法。其他构建树的方法我们前面的讨论是树的CART实现，其他常用的方法还有ID3，C4.5，C5.0。演化到C5.0已经和CART类似，一个C5.0重要的特征是有一组规则组，随着树的增长，分类规则可以简化，直到定义完叶节点。线性组合分割除了限制分割以形式，还可以用线性组合的形式。这里的权重和分割点s都通过最小化不纯度（比如gini系数）来得到。这种方法提升了其预测能力，但损失了解释性。一种更好的方法称为HME。树的不稳定性树的主要问题在于其高方差。一个小的改变可能造成一个非常不同的分割。主要原因在于其继承的本质。上层分割的误差会被传递到其后的下层。Bagging算法可以通过构造多棵树来减少方差。缺失平滑性对于分类树而言，这种平滑性缺失影响不大，但对于回归树而言，却是一个很大的限制。MARS是一种针对此改进的方法。可加结构添加困难对于添加了噪音的树结构而言，很难去表达这种噪音。MARS放弃了这种树结构来捕获可加结构。","categories": ["机器学习"],
        "tags": ["ESL","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/tree/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "神经网络",
        "excerpt":"简介在这一章我们描述了一类学习方法，它们分别在统计和人工智能领域独立发展过，但模型却是一致的。其中的核心思想就是将输入的线性组合作为特征，将目标建模为这些特征的非线性函数。这种方法在很多领域广泛应用。我们首先介绍投影寻踪模型，然后再介绍神经网络模型。投影寻踪回归假设我们有一个输入向量X长度为p，和一个目标值Y。令是一组长度为p的向量构成的未知参数，则投影寻踪回归模型具有以下的形式：这是一个加性模型，但特征是而不是输入本身。函数是非指定的。函数被称为的桥函数。其只在向量方向变化。相当于在单位向量方向上的投射。是需要模型拟合的参数。PPR模型主要用于分类，对于产生解释性模型比较无力，只有是个例外，相当于线性回归的更一般化。给定训练样本，如何来拟合PPR模型？令损失函数为：和其他平滑问题一样，需要为添加复杂的限制来避免过拟合。考虑的情况，给定方向向量，我们得到，然后通过散点平滑方法来得到g的估计。另一方面，给定g后，需要最小化。高斯牛顿搜索可以解决这个问题，通过将二次导舍弃，我们可以近似得到：因此可以近似得到：通过对于上面两步的交替迭代，直到拟合。神经网络神经网络被传得神神道道，其实只不过是一个非线性统计模型。一个典型的神经网络是一个两层的回归或分类模型。作为回归模型时上层只有一个。对于k类分类问题，上层有K个单元，第k个单元代表第k类的可能性，用来衡量，每一个都是0-1之间的取值。提取的特征通过对输入进行线性组合构造成，目标值则是的函数：激励函数常常选择S型函数，有时候高斯径向基函数也被用作，这时神经网络被称为径向基网络。从上面的公式中可以看出，对每个隐藏层和输出层，都添加了额外的偏差。输出函数允许对输出T做最后的转换。对于回归，一般都选择本身，对于K类分类，则选择softmax函数：如果把看做原始输入X的基本扩展，那么神经网络就是一个标准的线性模型。如果也是个恒等函数，那模型也可以看做针对输入的线性模型。因此神经网络可以被视为对线性模型的非线性泛化，这个结论对回归和分类都使用。注意到一层隐含层的神经网络模型和上一节中的投影寻踪模型具有一致的形式。神经网络拟合神经网络的未知参数，常常被称为权重。对于回归来说，使用平方和误差作为误差函数：对于分类而言，使用平方和误差或者互熵：对应的分类就是 。使用softmax激励函数和互熵误差函数，神经网络在隐藏层就是一个逻辑回归模型，所有参数可以通过最大似然性得到。标准的最小化做法是通过梯度递减，在这里被称为反向传播算法。令，令。对于平方和误差而言，由于：其导数为：得到导数后，根据梯度下降算法：其中是学习率。将导数记为：其中是模型在输出层和隐藏层的误差。根据定义，它们满足以下关系：上面这个式子被称为反向传播等式。利用这个，参数更新可以通过两步走。正向走时，当前权重固定，预测值计算得到，反向走时，误差计算得到，进一步得到。然后再去更新参数。这个算法也被称为反向传播算法。反向传播算法的优点在于其简单和本地属性。但它的速度比较慢，牛顿方法同样不适用（R的海森矩阵计算量大）。更好的拟合方法是共轭梯度和变度算法。神经网络训练的讨论初始值过拟合输入范围隐藏单元和层的数目多极小值","categories": ["机器学习"],
        "tags": ["ESL","机器学习算法"],
        "url": "http://localhost:4000/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/neural-networks/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "sql练习",
        "excerpt":"      Find the model number, speed and hard drive capacity for all the PCs with prices below $500.Result set: model, speed, hd.    select model, speed, hdfrom PCwhere price&lt;500;            List all printer makers. Result set: maker.    select distinct makerfrom Productwhere type='Printer';            Find the model number, RAM and screen size of the laptops with prices over $1000.    select model, ram, screenfrom Laptopwhere price&gt;1000;            Find all records from the Printer table containing data about color printers.    select *from Printerwhere color='y';            Find the model number, speed and hard drive capacity of PCs cheaper than $600 having a 12x or a 24x CD drive.    select model, speed, hdfrom PCwhere price&lt;600and cd in ('12x','24x');            For each maker producing laptops with a hard drive capacity of 10 Gb or higher, find the speed of such laptops. Result set: maker, speed.    select distinct maker, speedfrom Product, Laptopwhere Product.model = Laptop.modeland hd &gt;= 10;            Find out the models and prices for all the products (of any type) produced by maker B.    select Product.model, pricefrom Product, PCwhere Product.model = PC.modeland maker='B'unionselect Product.model, pricefrom Product, Laptopwhere Product.model = Laptop.modeland maker='B'unionselect Product.model, pricefrom Product, Printerwhere Product.model = Printer.modeland maker='B';            Find the makers producing PCs but not laptops.    select distinct makerfrom Productwhere type='PC'and maker not in(select distinct makerfrom Productwhere type='Laptop')            Find the makers of PCs with a processor speed of 450 MHz or more. Result set: maker.    select distinct makerfrom Product, PCwhere Product.model = PC.modeland speed &gt;= 450;            Find the printer models having the highest price. Result set: model, price.    select model, pricefrom Printerwhere price =(select max(price)from Printer);            Find out the average speed of PCs.    select avg(speed)from PC;            Find out the average speed of the laptops priced over $1000.    select avg(speed)from Laptopwhere price &gt; 1000;            Find out the average speed of the PCs produced by maker A.    select avg(speed)from Product, PCwhere Product.model = PC.modeland maker='A';            Get the makers who produce only one product type and more than one model. Output: maker, type.    select distinct maker, typefrom Productwhere maker in(select makerfrom Productgroup by makerhaving count(distinct type)=1and count(distinct model)&gt;1);            Get hard drive capacities that are identical for two or more PCs. Result set: hd.    select hdfrom PCgroup by hdhaving count(*) &gt; 1            Get pairs of PC models with identical speeds and the same RAM capacity. Each resulting pair should be displayed only once, i.e. (i, j) but not (j, i). Result set: model with the bigger number, model with the smaller number, speed, and RAM.    select distinct p1.model, p2.model, p1.speed, p1.ramfrom PC p1, PC p2where p1.model &gt; p2.modeland p1.speed = p2.speedand p1.ram = p2.ram;            Get the laptop models that have a speed smaller than the speed of any PC. Result set: type, model, speed.    select distinct type, Product.model, speedfrom Product, Laptopwhere Product.model = Laptop.modeland speed &lt;(select min(speed)from PC);            Find the makers of the cheapest color printers.Result set: maker, price.    select distinct maker, pricefrom Printer, Productwhere Product.model=Printer.modeland color='y'and price=(select min(price)from Printerwhere color='y');            For each maker having models in the Laptop table, find out the average screen size of the laptops he produces. Result set: maker, average screen size.    select maker, avg(screen)from Product, Laptopwhere Product.model = Laptop.modelgroup by maker;            Find the makers producing at least three distinct models of PCs. Result set: maker, number of PC models.    select maker, count(model)from Productwhere type='PC'group by makerhaving count(model) &gt;= 3;            Find out the maximum PC price for each maker having models in the PC table. Result set: maker, maximum price.    select maker, max(price)from Product, PCwhere Product.model = PC.modelgroup by maker;            For each value of PC speed that exceeds 600 MHz, find out the average price of PCs with identical speeds. Result set: speed, average price.    select speed, avg(price)from PCwhere speed &gt; 600group by speed;            Get the makers producing both PCs having a speed of 750 MHz or higher and laptops with a speed of 750 MHz or higher. Result set: maker    select distinct makerfrom Product, PCwhere Product.model = PC.modeland speed &gt;= 750and maker in(select distinct makerfrom Product, Laptopwhere Product.model = Laptop.modeland speed &gt;= 750)            List the models of any type having the highest price of all products present in the database.    select distinct modelfrom(select model, pricefrom PCunion allselect model, pricefrom Laptopunion allselect model, pricefrom Printer) as union_modelwhere price &gt;= all(select price from (select price from PCunion allselect price from Laptopunion allselect price from Printer) as union_price);            Find the printer makers also producing PCs with the lowest RAM capacity and the highest processor speed of all PCs having the lowest RAM capacity. Result set: maker.    select distinct makerfrom Product, PCwhere Product.model = PC.modeland ram =(select min(ram)from PC)and speed =(select max(speed)from PCwhere ram =(select min(ram)from PC))and maker in(select makerfrom Productwhere type='Printer');            Find out the average price of PCs and laptops produced by maker A. Result set: one overall average price for all items.    select avg(price)from(select pricefrom Product, PCwhere Product.model = PC.modeland maker = 'A'union allselect pricefrom Product, Laptopwhere Product.model = Laptop.modeland maker='A') as union_price;            Find out the average hard disk drive capacity of PCs produced by makers who also manufacture printers.Result set: maker, average HDD capacity.    select maker, avg(hd)from Product, PCwhere Product.model = PC.modeland maker in(select distinct makerfrom Productwhere type='printer')group by maker;            Determine the average quantity of paint per square with an accuracy of two decimal places.    selectround(sum(ifnull(B_VOL,0))/count(distinct Q_ID),2)from utB right join utQon utB.B_Q_ID = utQ.Q_ID;            Under the assumption that receipts of money (inc) and payouts (out) are registered not more than once a day for each collection point [i.e. the primary key consists of (point, date)], write a query displaying cash flow data (point, date, income, expense).Use Income_o and Outcome_o tables.    select i.point, i.date, i.inc, o.outfrom Income_o i left join Outcome_o oon i.point = o.pointand i.date = o.dateunionselect o.point, o.date, i.inc, o.outfrom Outcome_o o left join Income_o ion o.point = i.pointand o.date = i.date            Under the assumption that receipts of money (inc) and payouts (out) can be registered any number of times a day for each collection point [i.e. the code column is the primary key], display a table with one corresponding row for each operating date of each collection point.Result set: point, date, total payout per day (out), total money intake per day (inc).Missing values are considered to be NULL.    select i.point, i.date, o.out, i.incfrom(select point, date, sum(inc) as incfrom Incomegroup by point, date) ileft join(select point, date, sum(out) as outfrom Outcomegroup by point, date) oon i.point = o.pointand i.date = o.dateunionselect o.point, o.date, o.out, i.incfrom(select point, date, sum(out) as outfrom Outcomegroup by point, date) oleft join(select point, date, sum(inc) as incfrom Incomegroup by point, date) ion o.point = i.pointand o.date = i.date;            For ship classes with a gun caliber of 16 in. or more, display the class and the country.    select class, countryfrom Classeswhere bore &gt;= 16;            One of the characteristics of a ship is one-half the cube of the calibre of its main guns (mw).Determine the average.    select country, round(avg(power(bore,3)*0.5),2)from(select country, bore, namefrom Classes, Shipswhere Classes.class = Ships.classunionselect country, bore, shipfrom Classes, Outcomeswhere Classes.class = Outcomes.ship) as new_shipsgroup by country;            Get the ships sunk in the North Atlantic battle.Result set: ship.    select shipfrom Outcomeswhere battle = 'North Atlantic'and result = 'sunk';            In accordance with the Washington Naval Treaty concluded in the beginning of 1922, it was prohibited to build battle ships with a displacement of more than 35 thousand tons.Get the ships violating this treaty (only consider ships for which the year of launch is known).List the names of the ships.    select distinct namefrom Ships, Classeswhere Ships.class = Classes.classand type = 'bb'and displacement &gt; 35000and launched &gt;= 1922;            Find models in the Product table consisting either of digits only or Latin letters (A-Z, case insensitive) only.Result set: model, type.    select model, typefrom Productwhere model regexp '^(([0-9]+)|([a-zA-Z]+))$';            List the names of lead ships in the database (including the Outcomes table).    select namefrom Shipswhere name in(select classfrom Classes)unionselect shipfrom Outcomeswhere ship in(select classfrom Classes);            Find classes for which only one ship exists in the database (including the Outcomes table).    select classfrom(select Classes.class, namefrom Classes, Shipswhere Classes.class = Ships.classunionselect class, ship as namefrom Classes, Outcomeswhere Classes.class = Outcomes.ship) as full_shipgroup by classhaving count(*) = 1;            Find countries that ever had classes of both battleships (‘bb’) and cruisers (‘bc’).    select distinct countryfrom Classeswhere type='bb'and country in(select distinct countryfrom Classeswhere type='bc');            Find the ships that “survived for future battles”; that is, after being damaged in a battle, they participated in another one, which occurred later.    select distinct o2.ship from(select ship, battle, result, datefrom Outcomes, Battleswhere Outcomes.battle = Battles.nameand result='damaged') as o1,(select ship, battle, result, datefrom Outcomes, Battleswhere Outcomes.battle = Battles.name) as o2where o1.ship = o2.shipand o1.date &lt; o2.date;            For the ships in the Ships table that have at least 10 guns, get the class, name, and country.    select Ships.class, name, countryfrom Ships left join Classeson Ships.class = Classes.classwhere numGuns &gt;= 10;            For the PC in the PC table with the maximum code value, obtain all its characteristics (except for the code) and display them in two columns: name of the characteristic (title of the corresponding column in the PC table);its respective value.    select 'model', modelfrom PCwhere code=(select max(code)from PC)unionselect 'speed', speedfrom PCwhere code=(select max(code)from PC)unionselect 'ram', ramfrom PCwhere code=(select max(code)from PC)unionselect 'hd', hdfrom PCwhere code=(select max(code)from PC)unionselect 'cd', cdfrom PCwhere code=(select max(code)from PC)unionselect 'price', pricefrom PCwhere code=(select max(code)from PC)            Find the names of ships sunk at battles, along with the names of the corresponding battles.    select ship, battlefrom Outcomeswhere result='sunk';            Get the battles that occurred in years when no ships were launched into water.    select namefrom Battleswhere year(date)not in(select launchedfrom Shipswhere launched is not null);            Find all ship names beginning with the letter R.    select namefrom Shipswhere name like 'R%'unionselect shipfrom Outcomeswhere ship like 'R%';            Find all ship names consisting of three or more words (e.g., King George V).Consider the words in ship names to be separated by single spaces, and the ship names to have no leading or trailing spaces.    select namefrom Shipswhere name like '% % %'unionselect shipfrom Outcomeswhere ship like '% % %';            For each ship that participated in the Battle of Guadalcanal, get its name, displacement, and the number of guns.    select distinct ship, displacement, numgunsfrom Classes left join Shipson classes.class=ships.classright join Outcomeson Classes.class=shipor ships.name=shipwhere battle='Guadalcanal';            Number the rows of the Product table as follows: makers in descending order of number of models produced by them (for manufacturers producing an equal number of models, their names are sorted in ascending alphabetical order); model numbers in ascending order.Result set: row number as described above, manufacturer’s name (maker), model.    select count(*) num, t1.maker, t1.modelfrom (select maker, model, cfrom Productjoin (select count(model) c, maker mfrom Productgroup by maker ) b1on maker = m) t1join(select maker, model, cfrom Productjoin (select count(model) c, maker mfrom Productgroup by maker ) b2on maker = m) t2on t2.c &gt; t1.cor t2.c=t1.c and t2.maker&lt;t1.makeror t2.c=t1.c and t2.maker=t1.maker and t2.model &lt;= t1.modelgroup by t1.maker, t1.modelorder by 1;            Find the ship classes having at least one ship sunk in battles.    select distinct Classes.classfrom Classes, Ships, Outcomeswhere Classes.class = Ships.classand Ships.name = Outcomes.shipand Outcomes.result = 'sunk'unionselect distinct classfrom Classes, Outcomeswhere Classes.class = Outcomes.shipand Outcomes.result = 'sunk';            Find the names of the ships having a gun caliber of 16 inches (including ships in the Outcomes table).    select namefrom Ships, Classeswhere Ships.class = Classes.classand bore = 16unionselect shipfrom Outcomes, Classeswhere Outcomes.ship = Classes.classand bore = 16;            Find the battles in which Kongo-class ships from the Ships table were engaged.    select battlefrom Outcomes, Shipswhere Outcomes.ship = Ships.nameand Ships.class = 'Kongo';      ","categories": ["实践"],
        "tags": ["SQL"],
        "url": "http://localhost:4000/%E5%AE%9E%E8%B7%B5/sql-exercise/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "ruby & gem & bundler",
        "excerpt":"rubyRuby was created by Matz, it is designed as a balance language just as its creator said:  I wanted a scripting language that was more powerfull than Perl, and more object-oriented than Python.So in Ruby everything is an Object, similar to Java.Ruby has some other features but I think they my be advanced 20 years ago, now are common.Ruby become popular for the web framework written in it: Ruby on Rails.Ruby on RailsRails is a web application development framework. In Java, there are Apache Struts and Spring. In Python, there is Django.GitHub, Airbnb, Hulu all are built with Ruby on Rails.The Rails philosophy includes two major guiding principles:  Don’t Repeat Yourself  Convention over configurationrbenvrbenv is a great way to manage several ruby versions. In fact, Python also have a pyenv, the usage is totally same, even the guide too. When I want to install ruby, We don’t need the offical RVM. I use the following way:brew install rbenv #auto install ruby-buildrbenv install -l # lookup the latest versionrbenv install 2.5.0rbenv global 2.5.0ruby -vAnd don’t forget to set up rbenv integration with the shell. Just append the line:eval \"$(rbenv init -)\"We can set ruby version in local directory by using:rbenv local 2.5.0To unset local version:rbenv local --unsetTo list all versions:rbenv versionsTo display current active version:rbenv versionTo uninstall ruby version:rbenv uninstall 2.5.0RubyGemsRubyGems is a package management framework for Ruby. Here we use it to install Bundler, Jekyll and all other things.gem install bundlergem have some other options, like list, search, update, uninstall.The offical RubyGems mirror is very slow in China, so we can change mirror:gem sources -lgem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/If you want to update gem itself, using:gem update --systemBundlerBundler provides a consistent environment for Ruby projects by tracking and install the exact gems and versions that are needed.In a word, Bundler deal with dependency.Bundle use a Gemfile to control the dependencies in the project directory.First generate a Gemfile:bundle initThen write the dependencies into the Gemfile, and install it:bundle install # bundle also fineIf you want to update the gems to the last version, use update (carefully);bundle updateBundler have its own mirror setting, by setting:bundle config mirror.https://rubygems.org https://gems.ruby-china.orgThe source in Gemfile will be replaced.","categories": ["笔记"],
        "tags": ["--","ruby","--","bundler","--","gem"],
        "url": "http://localhost:4000/%E7%AC%94%E8%AE%B0/ruby-gem-bundler/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "shadowsocksR",
        "excerpt":"时代在发展，shadowsocks源作者已经被请去喝茶了，现在更流行的一个叫shadowsocksR加强版，感谢两位作者。这里也趁着换VPS的同时新装了一个shadowsocksR。安装shadowsocksR在VPS上安装了最新的Ubuntu 16.04。然后发现可恶的搬瓦工对这个系统没有一键安装shadowsocks的脚本，在网上找了一下，发现这个哥们做了一键安装的脚本很有用：wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log安装完后配置都可以和原来保持一致，这样客户端就不用修改了。shadowsocksR的客户端客户端大家都是兼容的：Mac上我用的是ShadowsocksX-NG。IOS上我用的是Wingy，之前国区被下架了。","categories": ["工具"],
        "tags": ["shadowsocks","翻墙"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/shadowsocksr/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "人生的意义",
        "excerpt":"人生的意义人生的意义这个问题，我是在大约十六七岁高中时期第一次开始思考的，每天晚上熄灯后就在床上苦思冥想，偶尔也会和邻床一个爱好哲学的同学讨论几句，当时可能受马克思的影响比较深远，最后得到的答案是：幸福感是人生和人类的最终目标！在前不久我仍然把这句我个人邮箱签名的话作为人生意义的答案，但最近看了一本书《大问题》，里面有个问题让我重新思考起人生的意义，那个问题大意如此：有人发明了一种“快乐箱”，人只要进去就可以在里面感受到快乐，再也不愿意出来。现在轮到我来选择，我是否应该进去？如果我的答案里的幸福就是快乐的感受，那么显然我的答案是脆弱的。现在VR技术已经快速发展，”快乐箱“不久就能实现，难道所有的人类都应该爬进箱子吗？语义理解当一个概念出现的时候，第一步总是要从语义上去理解。人生的意义，谁的人生？意义怎么理解？对谁的意义？谁的人生谁的人生比较好回答，在这个问题中，我暂时只讨论我个人的人生，不讨论他人的人生，也不讨论群体的人生。意义怎么理解人生的歧义较少，即人的一生。但意义的理解则有很多。现代汉语词典中意义的基本解释有两种，第一种是语句的含义；第二种是作用，价值。那么在人生的意义这个用法里意义即是作用。对谁的意义？人生的意义是对谁而言的？对我个人而言？对身边人而言？对国家而言？对历史而言？可以对上面所有对象。人生角色和对象如果直接问你的人生有什么意义？这的确是个很难得问题。但换一个更具体的，你的工作有什么意义？大部分人都能说上一两句。这其实反映了一个重要的本质，即我们的人生是多面的，在不同场合，不同时期，面对不同对象，我们的人生角色也不同，人生的意义也不同。人生的各种比喻如果人生的意义本就可以有多种选择，那么《大问题》里面对人生有各种比喻下面挑选几种有意思的说法。人生是游戏把人生当做一场游戏，游戏本身是自洽的，它的意义源自于本身。我们在游戏中成长，也在游戏中获得乐趣。人生是故事人生是一个故事，类似的，是一部电影。自己就是自己的编剧，故事可以有不同类型，全都取决于自己的书写和选择。人生是悲剧人生是一部悲剧，这种观点需要被特别认真的对待，因为所有的人都面临着一个同样的结局–死亡。无论多么努力或者多么混乱，多么欢愉或者多么痛苦，我们都将走向死亡。如果我们意识到死亡的存在，仍然按自己的意愿活着，那就是一个悲剧英雄。人生是喜剧人生是一部喜剧，面对幸福，放声大笑；面对不幸，黑色幽默。幽默是一种神奇的态度，让我们笑对人生的变化，也在这个过程中，人重新成为自己人生的主宰。人生是使命人生是一种使命，无论是对神的弘扬还是为了一份伟大的事业，使命可以让人超越死亡，从而脱离了人生的悲剧性质。人生是艺术人生是一种艺术，人的一生最终是一份带上艺术家烙印的艺术品，因此得是趋于完美的，带有自己格调的，我们常常说时光雕刻，雕刻的正是这份艺术品。美本身也是哲学之外人最重要的能力。人生是冒险人生是一场冒险，尽情享受生活，不断寻求刺激，让人生为激情所驱动，不问未来会如何，意义就在当下时刻。人生是苦难人生是一种苦难，我们或受到外界环境施加的苦难，或为不断追寻水中印月的欲望而持续受苦，对此悲观主义者叔本华有一个解答：  我们的欲望终将是非理性的和无果的。出路在于通过审美的沉思冥想或禁欲的自我否定达到一种超然状态。意义和人生的关系到底是人生决定了意义，还是意义决定了人生，书中的这段话别有一番意思。  所以生活意义的问题并非只是发现的问题，它也是一种重要的创造活动。你自己的哲学仅仅在部分程度上是对你已有世界观的表述和澄清，因为你所提出的哲学也将为这种世界观的形成助一臂之力。于是，有些对世界持一种晦暗的悲观情绪的哲学家，会故意把他们的哲学表述得甚为欣喜和乐观，这不是为了欺骗自己，而是为了改变自己，其中的确有一些人获得了很大的成功。当我选择一种生活的意义时，它便真的成了我的意义。即使我的意义在我之外，在孩子那里，在上帝那里。甚至虚无主义本身也可以成为了生活的意义。因此可以这么说，意义既可以是年迈时对一生的总结，也可以是年轻时对一生的展望。荒谬和死亡面对人生的意义这个问题时，我们面临的最大两个敌人就是荒谬和死亡。两者分别对应了我们面对当下的焦虑和面对永恒的无力。破解荒谬人生的意义假如有所指向，那么就可以不停追问下去，比如假如说人生在于让人幸福。但幸福于人又有何意义呢？如此追问下去，人生的意义将无处可寻，最终不得不把人生归于荒谬或者上帝。作为一个无神论者，如何能够让人生逃离荒谬的陷阱？书中的这段话给我提供了思路。  生活的意义只有在我们的生活情境中才能找到，而不能诉诸生活以外的什么东西。对于一个真正为上帝活着的人而言，把自己献给上帝回答了生活的意义；对于一个真正为孩长活着的人而言，孩子回答了生活的意义。具有讽刺意味的是，只要一个人能够真正把生活致力于生活毫无意义这一命题，把人们通常赋予生活的有时是自以为是的错误而有害的意义清除掉，那么虚无主义——即认为生活毫无意义——同样可以赋予生活一种意义。加缪似乎就是以这种方式活着的。让人生的意义最终回到人生本身，让意义成为个人有意识的选择，我们就自然而然的破解了荒谬。在这一点上，加缪的《西西弗斯的神话》说的是对的，那就是:  如果这个神话是悲剧，那是因为它的英雄是有意识的。所以，现在来看，人生的意义最终选择了什么并非最重要的，重要的是对人生意义的自觉性，感受到自己的存在，清楚自己的选择。破解死亡我们又如何面对必然到来的死亡呢？如何用有限的生命去抗衡无限的死寂？在这一点上，人有两种对抗方式。一种是生物上的延续，繁衍子孙。从这个角度讲，世上大部分人都不自觉的完成了自己唯一的永恒使命。另一种更重要的是精神上的传承，肉体瞬逝而精神不死。让精神代代相传，让智慧摇曳生辉。古语云，朝闻道夕死可矣，我们不仅应做一个知道者，还应做一个传道者，最终做一个立道者。现在看来，我将幸福作为人生的意义的确还值得商榷，现在的我更倾向于把我的人生作为一个故事，写好每一次转折，一件艺术品，细细雕琢每一处细节，一份使命，弘扬不死精神，超越死亡。","categories": [],
        "tags": [],
        "url": "http://localhost:4000/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89/",
        "teaser":"http://localhost:4000/img/tree.jpg"},{
        "title": "博客重建",
        "excerpt":"今天花了整整一天的时候把我的博客重建起来了，主要是换了一个主题，然后剩下的时候就一直在折腾了。这次用了一个很受欢迎的minimal-mistakes，搞下来才发现它为啥叫迷你了，自己要设置的东西太多了！把自己DIY的主要几步记录一下，有几步真的挺繁琐的。如何安装和迁移先按我另一篇博文ruby &amp; gem &amp; bundler把bundler装起来，然后不用gem安装jekyll，直接搞个空文件夹，gemfile中添加：gem \"minimal-mistakes-jekyll\"然后用bundle就能安装了，这样装出来的jekyll才是配套的！老的文件夹中可以把_posts, _drafts, img, about.md搬过来，其他可以不用了。Configuration 配置项这个主题拥有一堆配置，下面我挑几个重要的记录一下。搜索自带搜索功能，我把搜索和全文搜索都打开了：search                   : true # true, false (default)search_full_content      : true # true, false (default)流量分析注册了一个google analytics， 不知道好使不，待观察。analytics:  provider               : \"google\" # false (default), \"google\", \"google-universal\", \"custom\"  google:    tracking_id          : \"UA-112430313-1\"默认博文配置这个可以指定博文大量的默认配置，很好使。我主要是添加了一个头部照片，默认开启目录，关闭分享，关联，阅读时间等比较鸡肋的东西。defaults:  # _posts  - scope:      path: \"\"      type: posts    values:      layout: single      author_profile: true      read_time: false      comments: true      share: false      related: false      toc: true      toc_label: 目录      header:        overlay_image: /img/sunrise.jpg        show_overlay_excerpt: false修改导航页导航页默认只有一个quick-guide，必须得改过来。修改导航配置需要将gems底下的_data/navigation.yml复制到自己的项目文件夹下，然后跟着修改：main:  - title: \"关于\"    url: /about  - title: \"博文\"    url: /year-archive/  - title: \"类别\"    url: /categories/  - title: \"标签\"    url: /tags/我的要求比较简单，只有四块：  关于： 自我介绍  博文： 全部博文，按年排列  类别： 按文件夹分组  标签： 按标签分组修改关于页在项目文件夹下新建一个about.md，正常写法即可。配置博文，类别，标签这三个其实是一样，只不过用不同的条件聚合。可以直接用minal mistakes提供的模板，分别放到自己在上面配置中指定的文件夹下。  All Posts Grouped by Category – List View  All Posts Grouped by Tag – List View  All Posts Grouped by Year – List View我在这里category里面的关键词没用官方的categories，自己修改成了category，因为我认为博文只能属于一个文件夹，可以属于多个标签。修改社交账号链接在这里想给自己配置一个豆瓣账号的连接，但看模板的官方指导要用Font Awesome icon，不幸的是这个网站上没有我大豆瓣的图标，凭着我少的可怜的css知识愣是没搞定自己做一个。后来从原来的Hux模板那边得到了灵感，结果发现直接搬过来的代码不适用，最后研究了半天官方文档，才发现version 5的这个版本用法已经不一样了，事实证明第一时间还是应该找官方文档啊。下面奉上我三小时的心血，在_includes/author-profile.html中添加：&lt;li&gt;  &lt;a href=\"https://www.douban.com/people/48573787/\" itemprop=\"sameAs\"&gt;    &lt;span class=\"fa-layers fa-fw\"&gt;      &lt;i class=\"fas fa-circle\"&gt;&lt;/i&gt;      &lt;span class=\"fa-layers-text fa-inverse\" data-fa-transform=\"shrink-4\"&gt;豆&lt;/span&gt;    &lt;/span&gt;    Douban  &lt;/a&gt;&lt;/li&gt;修改主页面minimal主题的主页面是有自己的home类型layout，而且必须是index.html，不能是md文件。主页面有点丑，最好加个图，会好看些：header:  image: /img/niubeiliang.jpg支持mathjaxkramdown是支持mathjax的，但是需要自己配置一个，参考github上一个小哥的意见，可以在_includes/scripts.html中配置一段：&lt;script type=\"text/javascript\" async  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;这样就会调用mathjax做渲染了。好了，博客搭的不容易，后面好好学习，好好思考。","categories": ["工具"],
        "tags": ["jekyll","github"],
        "url": "http://localhost:4000/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%BB%BA/",
        "teaser":"http://localhost:4000/img/tree.jpg"}]
